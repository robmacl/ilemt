Todo:
 -- Realtime code: signal processing and pose solution
 -- Problems with low rate pose solution not converging with
    rotated_dipole.  Have high rate concentric_cal_file in
    output_correction(). Being set in local_check_options.m
 -- Does low rate need a different valid_threshold?
 -- Problems with linear correction when the pose solutions are
    terrible. 

Don't forget:
 -- Would be better if cal data was not effectively a subset of test
    data, eg. slight rotation/translation.  We add only interior XYZ points.
 -- Source lead wires may be having significant effect, source cross
    coupling changed quite a bit when I relocated the source on the
    source mover.
 -- worry about trans2pose, change to using tr2angvec and orthonormal test.
 -- quadrupole calibration anomaly between cal_7_21_premo_dipole and
    cal_7_29_premo_dipole.  See [3 Aug 21].  Note that I was not using the
    'source' data pattern on 7/21.  Does sensor rotation help source
    identification?  Or the 'source' pattern just gives worse results, such as
    from larger translation than used in the test?  But also maybe just bad
    setup on 7/21.


Accuracy:
 -- Test ascension tracker accuracy in same setup
 -- Out-of-position tests: straight line and gross rotation
 -- Test stage accuracy:
     - Double-check stage backlash compensation.  Is the backup big enough?
     - Stage performance checks using square and gauge blocks
 -- Normalization/weighting/sensitivity.  What is effect on accuracy if sensor
    ground truth rotation is wrong?
 -- Visualize/test fields generated by forward kinematics
 -- Other kinds of magnetic calibration model?


Work for source/sensor paper (cross coupling, or source/sensor, system)
 -- straight-line dipole approximating source
 -- Field mapping with one vs. three dipole coils to investigate
    cross-coupling? 
 -- Cross coupling simulations
 -- Literature search
 -- Sensitivity test?  Full results don't belong here, but useful for
    understanding.


Source/sensor configuration variations:
  Sensors:
    se_dipole
    Premo concentric cube
    se_dipole_linear?
    Premo compact?
  Sources:
    so_dipole_corner
    so_dipole_corner_rotated
    so_dipole_linear
    CMU concentric cube
    Premo concentric?


Probably too small to matter:
 -- Inside box coupling bias, compensate or shield
 -- Magnetic interference from stage setup


Maybe later:
 -- Other more ad-hoc calibration parameters?
     - Could do eg. multilinear interpolation, but this is not going to work
       at all outside of the calibrated workspace.
     - LUT interpolation might generalize better if it was done in a more
       physically relevant coordinates, eg. coupling/magnetic


[20 Oct 21]

See ilemt_papers/calibration/stage_uncertainty.xlsx for computation of stage
position uncertainty.  By the specs it is not too bad for our purposes, 118
um/1.9 mrad, but this is not very credible, both because the stage is not
calibrated, and also because the specs do include the off-axis effects from
the large pole moment.

I dived into checking the stage accuracy, and of course it was not always as
good as I would have liked.  See notebook #2 pages 10-12, and also the tables
in compensate_stage() (described below).

Many of the measurements are quite good, within the specs even though we are
including the pole and extra moment from the indicator reach-out.  Good
measurements are:
    X->Y
    Y->X (including XY non-square)
    XY->Z
    Rz repeatability
    Rz accuracy

I haven't evaluated the stage components individually, without the pole, but
it seems that in particular the XY off-axis and the Rz accuracy are much
better than the spec.  The Rz accuracy spec is terrible, but with only +/- 90
degree tests we can't really contradict it.  The Rz repeatability ia similar
to the spec.

But these are ugly:
    Z->X (220 um TIR)
    Z->Z (130 um TIR)
    X->X (155 um TIR)
    (haven't measured Y->Y yet)

If these are present right at the stage axes (without the pole moment), then
these are way out of spec.  The from-Z effects have been visible all along in
the calibration results, but I had supposed that it was a magnetic effect.
"Why does it all go bad at Z<0?"

Wrote ilemt/matlab/calibration/compensate_stage.m, which adds the measured
errors into the commanded stage position to increase the effective stage
accuracy.  This seems to "work"; it reduces the calibration residual (10%) and
the calibration error (especially w/o output correction).  The function can
deal with any of the 9 XYZ interactions, but I am thinking that it is
reasonable to only correct the bad ones.  Anything less than 15 um uncertainty
(30 um TIR) is not going to have any significant contribution.  The Z->X and
Z->Z corrections noticeably help, while the X->X effect is not so much (but if
the sign is swapped it increases the residue).

Of course it is not necessarily the case that positioning error will degrade
these internal measures; the whole point of characterizing the stage
uncertainty is that positioning errors can go undetected by the residual.  But
if the calibration model (dipole) can't absorb these errors, then some of it
is going to appear in the residual and calibration error.

For the actual accuracy the problem is not the positioning error that ends up
in the residue, but rather the error that *doesn't*.  As I had suspected, the
linear correction is rather good at absorbing stage error, since compensating
the stage error improves the uncorrected calibration error (13%) more than it
improves the corrected error (8%).  This "improvement" from the output
correction is precisely the process of absorbing positioning error into the
calibration.

Given the "ugliness" (nonlinearity) of the bad responses it is kind of hard to
be confident how stable those deviations will be.  eg. for the X on-axis
error, most of the error (100 um) is between -25 and -50, and Z issues are
mainly in ther -Z range.  Whether this is wear or misalignment or just dirt,
who knows.

These errors are big enough that it's certainly going to be better to correct
than to not correct, but we should repeat the stage error measurements before
any critical calibration.  The reduction in residue on the calibration data
from a month ago shows that things haven't changed too much.

As you would expect, with the CMU concentric source (and its higher error) the
compensation has basically no effect on calibration error and residual.  This
level of stage error is really only visible when the tracker accuracy is
higher.


[11 Oct 21]

Not sure what to say about stage accuracy.  I need to say something, but going
into detail also seems rather too much for this context.  I guess it could be
an appendix.  The component specs are not tremendously helpful. The on-axis
and perpendicular error specs for the linear axes are decent, but there isn't
any rock-n-roll moment error spec.

For the Rz axis there is a wobble spec which is 60 arc sec (290 urad), which
over the pole moment of 0.7 m gives 200 um.  Rz does seem to be the biggest
contributor to non-reproducible off-axis error, but what I've typically seen
is more like 25 um, sometimes more, but well less than 50 um.

Not sure how they define wobble, it may be the perpendicularity with respect
to the base, in which case we would largely cancel any repeatable first order
effect through the sensor fixture transform.  That is, a centered pole normal
to the turntable will to some degree sweep out a cone, but at any particular
height (such as our pole length) this will amount to a circle of a particular
radius.  Since we already allow for an offset between the sensor and the Rz
axis we will absorb the circular error by making the offset moment larger or
smaller.

I think that the Rz alignment also must have a similar effect.  The thing is
that the pole itself is only very roughly normal to any axis, so the top of
the pole is going to be experiencing all sorts of wobble.  But I have aligned
the sensor fixture to the Z (translation) axis to insure that the fixture Z
axis is parallel to the stage Z axis.  Then the Rz alignment makes the Z axes
cooincident.  This makes the non-perpendicular of the pole itself irrelevant,
because we place the fixture origin over the Rz origin.  The pole could be at
any angle.

But what happens with non-parallelism between the Rz and Z?  Then we will see
a circular XY movement of the fixture under Rz motion that varies by the Z
offset (opposite in phase above and below the workspace center).  Insofar as
this exists (and is not somehow compensated) it seems to be smaller than other
errors, since we don't see a clear interaction between Rz and XY error in the
grid data tests.  For the axis sweep we would not expect to see much because
it is done at the center of the workspace (and we do not see any such).

How much would we expect given the wobble spec?  Now the moment is only the Z
offset, 50mm, giving 15 um for 290 urad wobble.  This is indeed small enough
to be lost in the other errors.


Here are the specs:
Z axis:
    Daedal 806004CT
    Positional accuracy: 15 um
    Straight line: 8 um
    Flatness: 8 um
    Repeatability: 5 um

XY axis:
   Daedal 300 AT series, 310062AT
   Positional repeatability (bidirectional): +/- 12 um
   X-Y squareness: 60 arc sec (291 urad)
   Positional accuracy: 24 um
   Straightness and flatness: 76 um

Rz axis:
   Daedal 200RT series, 20801RTES
   Positional repeatability (unidirectional): 0.5 arc min (145 urad)
   Runout: +/- 75 um
   Concentricity: +/- 127 um
   Wobble: 60 arc sec (291 urad)
   Accuracy: 10 arc min (2900 urad)
[I'm guessing that "concentricity" is how far the rotation axis is from the
center of the stage, and "runout" is the residual indication after you have
nulled the concentricity.  That is, it is higher order error or noise.  What
I've actually seen in Rz alignment is non-reproducible noise, probably mostly
"wobble".] 

These specs are for "standard precision", many "precision grade" specs are 2x
or more better.  

Taking just the XYZ linear specs and combining vector sum:
   sqrt(sum(([15 8 8 12 24 76]*1e-6).^2))
   = 83 um

If we add the Rz runout and 50mm moment effects for XY non-square and Rz
wobble, then we get:
   sqrt(sum(([15 8 8 12 24 76 75 291*50e-3 291*50e-3]*1e-6).^2))
   = 114 um
(This assumes that Rz alignment has caused the effective wobble moment to be
the 50mm Z motion rather than the 700mm sensor height.)

This seems kind of bad, but if we add it to a 200 um tracker error, the
combined error is only increased 15%:
   sqrt(sum(([15 8 8 12 24 76 75 291*50e-3 291*50e-3 200]*1e-6).^2))
   = 230 um

We are ignoring the unspecified rock-n-roll of the XYZ axes, but this does
seem to be pretty small (hard to see compared to Rz effect).  Also on the wiki
page I claim that the XY orthogonality is out of spec.  But our uncertaintly
is heavily dominated by the 76 um XY "straightness and flatness" and the 75 um
Rz "runout".

The stage specs would be max specs, not RMS, would make them conservative when
set beside the RMS tracker error.  That is, we are combining them as though
they were RMS. But supposing that the stage error was Gaussian then RMS would
be a fraction of the max.

Should also consider error in the source and sensor fixtures, where there is
no "spec".


 ==> I hadn't realized that root-sum-square was considered the default way to
     combine uncertainties, and how this affects the required positioning
     accuracy.  If the assumption of uncorrelated errors is justified, then we
     don't need as much accuracy as I was thinking.  That is, 3x better is
     quite reasonable, where I had hoped for up to 10x.

Is the assumption of uncorrelated errors justified here?  For the stage itself
it is as justified as in any other general situation.  But post-calibration
the tracker error *is* correlated with the stage error.  That is, it will have
a component that mirrors the stage error, rather than being unrelated.  But if
the calibration could track the stage error quite closely then the calibration
error would appear quite small, and the total uncertainty would be (correctly)
dominated by the stage uncertainty.  Insofar as the tracker calibration is
modelling the stage error, these do not add together.  So I guess it does work
for the calibration result as well.

While an error of 15% in the uncertainty spec seems fine from an engineering
perspective, you would need care to rigorously make fine distinctions between
the performance of different calibrations, hardware configurations, or
trackers.  If the difference is in this range then you would have to consider
the possibility that it is non-reproducible.  Given that the stage error specs
are conservative, and that some of the stage error is reproducible, then it is
likely that differences on this scale *will* be reproduced, but if this is
important the you really should show that it is reproducible by reproducing it.


A thought here is that I don't entirely understand how the fixture transforms
may be cancelling deterministic stage error.  But I think that this also
doesn't matter as long as we are just incorporating stage error into the
fixture transforms (and not into the calibration).

The general linear output correction probably *is* incorporating stage error
into the calibration.  At least, it is fairly well positioned to incorporate
translation non-orthogonality and scale factor error. (But it is in source
coordinates, which are rotated wrt. the stage, at least with rotated
dipole. And the translation axes rotate dynamically with Rz.)


Although this is not a rigorous assertion, non-reproducible error is not as
big a problem as reproducible, because (unless it is reproduced by chance) it
will mainly inflate the measured error.  This is sort of adjacent to the
uncorrelated-error assumption underlying the root-sum-square rule.


[23 Sep 21]

First look at cal_9_16_premo_rotated_dipole.  I was thinking this was
bad data somehow, but maybe not?  The big difference is with the
source fixture data, both in calibration and testing.  But it is
reasonable that these results might change quite a bit because we are
using very different data than before.  There is now far more data in
other source fixtures.

But if I include soXinYup_seYoutZup_ld then I am getting max rotation
errors of ~180 degrees even in XYZ_all/so fix, and max XYZ errors of
200-300 mm.  The file is however sane according to calibrate_main
Z_only.

There are solutions that fail the valid test, and maybe really did not
converge.  I need more summary information so I don't have to wade
through the test_output.txt, looking for invalid poses, excess drift,
excess error.

 ==> I get sane results with soXinYup if I discard invalid poses.
 ==> Also, it seem something moved, since it is much better with
     'optimize_fixtures', {'stage'}

________________________________________________________________
cp=check_poses('cal_file', 'XYZ_hr_cal', 'in_files',{'soXinYup_seYoutZup_ld.dat'}, 'discard_invalid', true, 'optimize_fixtures', {'stage'})

Checking from: C:\Users\robma\Documents\Work\ilemt_cal_data\cal_9_16_premo_rotated_dipole
               cal_file: 'XYZ_hr_cal'
                variant: 'default'
               in_files: {'soXinYup_seYoutZup_ld.dat'}
      linear_correction: 1
          pose_solution: 'optimize'
    concentric_cal_file: 'XYZ_concentric_hr_cal'
                 ishigh: 1
        valid_threshold: 1e-05
        discard_invalid: 1
      optimize_fixtures: {'stage'}
                 moment: 0.05
             hemisphere: 0
              sg_filt_N: 2
              sg_filt_F: 11
         xyz_exaggerate: [10 300 1 30]
           stage_coords: 1
                reports: {'overall'  'workspace'}
        drift_threshold: 2e-05
        error_threshold: 0.002
          axis_response: 6
           plot_on_axis: 0
         scatter_x_axis: 'residual'
           sensor_signs: {}
           source_signs: {}
Discarding 23 invalid poses with residual > 1e-05
Optimizing fixture poses:
    {'stage'}
source_fix_delta =
     0     0     0     0     0     0
stage_fix_delta =
  -0.00063613    -0.001314   -0.0072497    -0.037519   -0.0072311    0.0014609
sensor_fix_delta =
     0     0     0     0     0     0
Position error (m): 1.01e-03 RMS, 2.28e-03 max.
Orientation error (radians): 8.38e-03 RMS, 1.74e-02 max
Warning: drift 3.16e-05 in soXinYup_seYoutZup_ld.dat:   -2.0418e-05   4.3726e-06   8.6832e-06   8.4073e-05   1.5442e-05   0.00015859
________________________________________________________________

Moved 7mm in Z and 2 degrees in Rx???

 ==> Oops, here's a problem.  We don't have a correct source fixture
     transform until we do an _all calibration (it is whatever we got
     from the initial base_calibration).  If the source fixture
     transform is wrong then it is totally not going to work when we
     have source fixture motion.  This is exaggerating the benefit of
     the _all calibration.


So, what does make sense for the source fixture in the mismatch
condition: XYZ_hr_cal, "source fixture" variant?

We need to have some sort of newly estimated source fixture to get any kind of
reasonable results.  So we want to have a source fixture, but without the
magnetic calibration having been exposed to the source fixture data.

So, remind me how using the calibration fixture transform is better than
optimizing the fixture in check_poses?  Either one seems defensible, but
check_poses() uses the actual test data, so clearly gives a lower error.
[Not optimizing avoids runtime in check_poses.]

The thing most in the spirit of using the calibration-time fixtures would be
for XYZ to optimize source fixture only using the same source fixtures as will
be in the test.  (FWIW, doesn't seem to make a lot of difference whether we
use all the sensor fixtures or not, but might as well)


[22 Sep 21]

Got the low rate calibration mostly working.  For some reason there
are convergence problems with low rate on rotated-dipole.

At least some of the problems where linear correction is not working
is when the pose solution does not converge during
output_correction().  But it still converges when doing plain
check_poses()?  How can we see lower error uncorrected?

I added features to output_correction() to see which of 'none', 'pinv'
and 'DLT' work best, and then also 'optimize' does general
optimization of the linear transform.  This means that we will never
generate a linear correction which makes things worse on the
calibration data, at least as it is constructed during
output_correction().  But maybe there is some problem with how we are
configuring find_pose_errors() in output_correction()?
 ==> I think we don't have the right concentric_cal_file

Also, we are testing with different data than in calibration, which
may explain why linear correction can make things worse.

For correction it would be fine filter the points based on the
ground truth error, but threshold may vary?  Probably silly anyway
to linear correct concentric w/ rotated-dipole.


[8 Sep 21]

Not sure why pose solution convergence using the concentric calibration
started to be a problem in cal_9_1_premo_rotated_dipole when it was not in
cal_5_25_premo_rotated_dipole, but I added a hack where if the residual is too
big, then we try sucessively flipping the sign of each element in the initial
pose, and this seems to be working.  With this change, we get rid of all the
convergence failures in the result.

FWIW, in the base XYZ configuration (no source fixtures) it was only failing
at the all-negative corner of the test pattern.  With fixtures it fails a lot
more.  We still get many fewer failures with the concentric calibration
[initial value] than without.  This may be in part because the other path
(based on the fixture transform) does not include the fixture motion.


[1 Sep 21]

Thinking on it a bit, I realized recency bias made me too concerned with
mechanical issues.  The drift (and initial 1/f noise) seems to have been a
problem with the the reference channel.  What was particularly suggestive was
that yesterday the drift was reduced when the reference compensation was
*off*.  It had only drifted another 40um overnight, and drift was worse
without reference compensation, but 1/f was much better with the reference
off.  Even then I was getting high rate 1/f similar in amplitude to the HF
noise and vibration, which is not how it should be.

I swapped the third input card into slot 0.  The first prototype with all the
reference channel bodges was in slot 0, and reference issues could definitely
explain noise and gain variation.  But possibly card 0 was loose in the
socket?

It is getting moderately hot inside the box, but not terrible.  The driver
heatsinks are hot to the touch, and the DAC and input slot 0 are warm,
decreasing away from the power section.  I expect that fan cooling would help
the drift.  Probably also reliablity, especially given the DIY reflow process.

re. the distance magnitude of drift threshold.  We can't set the drift
threshold any tighter than the drift we are seeing when things are working
right.  But it would be nice to know what the drift is in distance units.  The
most direct way to get at that would be to compare the pose solutions for the
drift in check_poses().

 ==> After swapping cards, the drift was 7.5um (!) during a large collection.

I added 'drift' report to check_poses(), and we were getting up to 60
um drift with cal_5_28_premo_rotated_dipole.  Similar in cal_7_30_premo_cmu. 


[31 Aug 21]

Got the sensor fixture tweaked in.  The rotation center alignment with the
setup ball alignment tool seems to be better than 25 um.

I re-checked the source fixture, and it seems about where it was when I last
tested.  The side panels are parallel within 10 um, and the worst deviation of
the center (using source fixture ball tool) is 25 um.

As part of getting the Rz offset, I looked at repeatability.  The sensor
fixture is only repeatable to about 25 um, perhaps because of non-flat surface
due to the spray lacquer I put on.  (Note that some of the source and sensor
fixture internal error can be absorbed into the fixture transforms.)

Also, as noted earlier, there is up to 25 um deviation in Y motion on the
indicator when the Rz is moved and moved back.  Given the >100 um motion seen
in the middle of Rz moves, we can't expect all that much repeatability.  The
translation runout due to XZ moves seems much smaller, <= 10 um.  The on-axis
Y non-repeatability is perhaps as much as 30 um?  Something moved, anyway.

While this is somewhat disappointing, it should not be all that surprising.
The sensor fixture is definitely a lot more accurate than it was before, now I
tweaked it for center of rotation and squareness, and we have the side stop.
It was almost certainly 100-200 um off before.

I'd like to do tests of the stage accuracy and runout with surface plate and
gauge blocks.


Pulling back, so far as the *project* goals go, I've gotten the position
accuracy into a range where the ground truth is starting to become limiting,
even though position accuracy was never the primary goal anway.


Given problems with fixture non-repeatability, I should really be folding
re-fixturings into my process somehow.  It would be obvious to re-fixture
between calibration and test data, but maybe this doesn't really make sense?
That would surely increase the measured error somewhat.  While this is in part
noise, it also stands in for the unknown inaccuracy of the ground truth, which
is limiting on the genuine tracker accuracy.  Getting a calibration that
precisely fits the error of the ground truth is not what the user wants.


FWIW, the ilemt_ui radial distance measure drifts at least 10's of um over the
course of a calibration collection.  Just now it is at 130 um, after doing
medium and large data, on first fixture.  This may well be mechanical drifts
in the setup due to room temperature and the new setup "settling down" after
being modified.  It could also be actual drift of the tracker.  Whatever the
source, this is another contributor to non-repeatability, and so to both
measured and actual error.
 ==> Hmmn.  It drifted another +125 um when I repeated large data?  Or I
     forgot to "Set ref"?  I don't think so.  May need to let things settle
     for a day or two.  I'm suspicious of the source slider setup.  But this
     could also be electronics, IDK.
 ==> And another +135 in the next sensor fixture, on big data.

I had kind of forgotten about the magnitude of measurement drift I was seeing
in ilemt_ui, in the process of trying to squeeze out the best calibration
accuracy numbers.  This also points back to the project goals, and micron
application, where a couple 100's of um drift over an hour was not a problem
at all.

For context, Delrin thermal expansion is ~ 1e-4 / degrees C.  So 1E-3 for 10C.
Then 100mm of Delrin expands 100um over 10C.  10C seems large for an ambient
temperature swing in the lab, but the source experiences more swing due to its
self heating.  We can get at ILEMT intrinsic drift better when everything is
on the surface plate, but it seems fairly plausible the fixtures+stage could
drift 100um from thermal effects.


What amplitude change corresponds to 125um/250mm?
  B=r^-3
  B=(1 + 125um/250mm)^-3

So we take the power not the root, and 125 um should be -56 dB, which would be
way over the drift threshold.  -80 dB should be 8 um.

The drifts we got in cal_5_28_premo_rotated_dipole are:
drift: soYoutZup_seYoutZup_ld.dat 4.92059e-05
drift: soYoutZup_seZinYup_ld.dat 7.30418e-05
drift: soYoutZup_seZinXdown_ld.dat 2.89979e-05

Yep, the drift check failed:
    drift: soYoutZup_seYoutZup_md.dat 4.0811e-05
    drift: soYoutZup_seYoutZup_ld.dat 0.000194152
    Warning: drift check failed: soYoutZup_seYoutZup_ld.dat 0.000194152
    drift: soYoutZup_seZinYup_ld.dat 0.000206551
    Warning: drift check failed: soYoutZup_seZinYup_ld.dat 0.000206551

That's semi-encouraging.  But I got -74 dB in the check?  Ah, but the drift
check is the max absolute difference, not the relative change.  Need to look
into that more.


Anyway, I don't want to do detailed characterization of drift until I get to
the system paper, so for now the first resort is to just wait and see if the
drift settles down.


At this point, with all the concerns about fixture accuracy, drift, and so on,
I am quite unsure whether the differences in calibrated accuracy I was seeing
are real or not.  It's certainly possible that the rotated corner dipole/premo
dataset was blessed by a planetary alignment.  When our error was >1mm all
this stuff was in the noise, but no longer.


[23 Aug 21]

Oops, definitely problems with the sensor fixture.  For one thing,
without the side stop, as seen in Rz alignment test, the position is
only accurate to 100 um or so (200 um TIR).  So quite significant.
Working on inspecting/tweaking the sensor fixture now.


[12 Aug 21]

The DLT correction method is giving a barking mad result for concentric w/ the
(non-concentric) dipole source.
cal.linear_correction =
     0.086618     -0.20997    -0.055111    -0.014904
   -0.0075112   0.00087745  -0.00099007   0.00087315
    -0.012606     0.015421     0.012537    0.0023218
      0.34989     -0.87513     -0.22982    -0.059948

This makes things much worse even on the exact input data.  'skew' method does
not make things worse.  Worth exploring correction method variations, since
while we do not care in this case, DLT may also be sub-optimal in useful
cases.

Could maybe do a better 6x6 transform correction computed from the error
transform that we now have?  Other generalizations of output correction,
correct rotation separately?


[10-11 Aug 21]

Summary:
 -- Got scripted testing working on several calibration datasets.
 -- Now reproducing the "best" error from [4 Jun 21] quite precisely (premo/
    rotated dipole).  But this dataset requires fixture optimization in
    check_poses() which gives a rather optimistic result.
 -- We see significant benefit from check_poses() fixture optimization on
    other datasets also.  See below for discussion on legitimacy of
    check_poses() fixture optimization.
 -- Experimented with doing fixture optimization in output_correction(), but
    this was not clearly a win, and has been left turned off.
 -- I am now pretty confident in the results that I am getting, that I have
    not broken anything with the source fixture changes.  And I have fixed a
    number of problems such as angle wrapping in check_poses() and
    with the 'optimize' pose solution, initializing the state using kim18() so
    that it converges on all test poses.
 -- What we see with source fixtures is pretty much what we would expect:
    calibrating over a larger workspace gives better results over that large
    workspace, but at some cost to the small workspace accuracy.


I'm now generating a summary table of the RMS/max errors in the
test_output.txt, so not duplicating that here.

Where we are so far with the test results:

cal_7_29_premo_dipole:
Pinned quadrupole is hurting vs. XYZ_all, even with multiple source fixtures.
The quadrupole runs did not terminate normally, were stopped from boredom and
negligible progress.

cal_7_30_premo_cmu:
Don't have a "ld" test file with source motion, so can't really test properly,
but even without source motion, so_quadrupole_all is noticeably better than
XYZ_all.

cal_5_28_premo_rotated_dipole:
I can reproduce the results from [4 June 21], but the star result of 2.28e-04
RMS, 4.93e-04 max is probably too good to be true because it is dependent on
fixture optimization in check_poses().  This is questionable because it
exploits the test data ground truth to minimize the very thing we are measuring.


This is the comparison of the so_quadrupole_all pinned quadrupole calibrations:
________________________________________________________________
>> print_calibration(load('C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_30_premo_cmu\so_quadrupole_all_hr_cal'))
                  d_source_pos                               d_source_moment                              d_sensor_pos                              d_sensor_moment           
    _________________________________________    _______________________________________    _________________________________________    _____________________________________
      -0.013459     0.00087463              0      0.80724    -0.00055374              0     0.00017334     2.1249e-05              0      0.39875    0.00029596             0
    -0.00055544      -0.011619              0            0        0.88779              0      3.096e-05     7.4892e-05              0            0       0.39748             0
       0.011386        0.01355              0    0.0013908     0.00040722        0.99093    -0.00027733    -0.00015048              0    0.0055368     0.0049771       0.40756
    q_source_pos              q_source_moment              q_sensor_pos    q_sensor_moment
    ____________    ___________________________________    ____________    _______________
    0    0    0       -2.7609     0.068673     0.013677    0    0    0       0    0    0  
    0    0    0     -0.043304      -2.3004     0.026672    0    0    0       0    0    0  
    0    0    0       -0.1726     0.068208      -2.9256    0    0    0       0    0    0  
Source fix: [0.00187 -0.00072 0.00278 0.03471 0.03991 -1.57398 ]
Stage fix: [0.00081 0.24340 0.01199 0.00043 0.00087 0.00538 ]
Sensor fix: [-0.00022 0.00019 -0.00016 -2.20091 -2.23145 -0.00021 ]

>> print_calibration(load('C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_29_premo_dipole\so_quadrupole_all_hr_cal'))
                 d_source_pos                             d_source_moment                             d_sensor_pos                              d_sensor_moment           
    _______________________________________    _____________________________________    _________________________________________    _____________________________________
     0.044815    -0.00091941              0      0.92954    -0.0046427             0     0.00019247     5.2316e-06              0      0.15899    0.00016303             0
    0.0024864       0.042705              0            0       0.93628             0     9.0142e-05    -2.7443e-05              0            0       0.15843             0
     -0.04343      -0.044092              0    -0.022963       0.00695       0.98721    -0.00016055    -9.1286e-05              0    0.0022149     0.0020553       0.16271
    q_source_pos                q_source_moment                q_sensor_pos    q_sensor_moment
    ____________    _______________________________________    ____________    _______________
    0    0    0       0.22131       0.017898     4.0178e-06    0    0    0       0    0    0  
    0    0    0      -0.13649       -0.77133    -4.5188e-06    0    0    0       0    0    0  
    0    0    0     -0.050858       -0.16923     0.00034344    0    0    0       0    0    0  
Source fix: [0.00257 0.00188 -0.01161 0.00989 0.01260 -1.58819 ]
Stage fix: [0.00037 0.24324 0.01203 -0.00003 0.00172 0.00805 ]
Sensor fix: [-0.00016 0.00017 -0.00017 -2.20121 -2.23167 -0.00016 ]
________________________________________________________________


Calibration is much slower than the premo/CMU combination, for whatever
reason.  Not just with the quadrupole.

The linear correction is now giving modest accuracy improvement under all test
conditions, even with source motion (when the motion is also in the
calibration data).


Going back to cal_5_25_premo_rotated_dipole and cal_5_28_premo_rotated_dipole,
I was able to approximately reproduce the results from [4 Jun 21].  Now
getting:
    Position error (m): 2.73e-04 RMS, 5.58e-04 max.
    Orientation error (radians): 5.32e-03 RMS, 1.11e-02 max
vs (then):
    Position error (m): 2.28e-04 RMS, 4.98e-04 max.
    Orientation error (radians): 5.99e-03 RMS, 1.12e-02 max

The result is somewhat worse for translation, but some variation is perhaps
not surprising, given that there has been a change in the optimization state
and the kinematics.  Translation is a bit worse, rotation a bit better.

I tried putting back the old somewhat stricter optimization termination
conditions, but the optimizer refused to do anything more.

 ==> I'd like to find the old no-correction results for comparison.  Nervous
     that the linear correction has been subtly degraded somehow.


 ==> From [1 Jun 21]
        (then)
        Position error (m): 3.46e-04 RMS, 9.03e-04 max.
	Orientation error (radians): 6.10e-03 RMS, 1.15e-02 max
	(now)
	Position error (m): 3.46e-04 RMS, 9.03e-04 max.
	Orientation error (radians): 6.10e-03 RMS, 1.15e-02 max

Hmmn, that is *exactly* the same.  So there might be something to the idea
that the linear correction is not working as well.

I compared the old linear correction with the new, and they are slightly
different, but the corrected accuracy is the same.  So I suspect the fixture
pose changes.

 ==> OK, we weren't allowing sensor fixture optimization.

Now we get:
    Position error (m): 2.28e-04 RMS, 4.94e-04 max.
    Orientation error (radians): 5.30e-03 RMS, 1.09e-02 max

Which is the nearly the same position error as on [4 Jun 24].

Hmmn, also seeing a quite significant benefit of fixture optimization with
cal_7_30_premo_cmu.
________________________________________________________________
>> check_poses('cal_file', 'XYZ_hr_cal')

Checking from: C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_30_premo_cmu
             cal_file: 'XYZ_hr_cal'
              variant: 'default'
             in_files: {'soYoutZup_seYoutZup_ld.dat'  'soYoutZup_seZinYup_ld.dat'  'soYoutZup_seZinXdown_ld.dat'}
    linear_correction: 1
        pose_solution: 'optimize'
    optimize_fixtures: {}
Position error (m): 6.03e-04 RMS, 1.24e-03 max.
Orientation error (radians): 4.93e-03 RMS, 1.06e-02 max
ans = 
  struct with fields:

        overall: [1×1 struct]
    cal_options: [1×1 struct]
        options: [1×1 struct]
           perr: [1×1 struct]
           onax: []
    calibration: [1×1 struct]
>> cp=check_poses('cal_file', 'XYZ_hr_cal', 'optimize_fixtures', {'stage', 'sensor'});

Checking from: C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_30_premo_cmu
             cal_file: 'XYZ_hr_cal'
              variant: 'default'
             in_files: {'soYoutZup_seYoutZup_ld.dat'  'soYoutZup_seZinYup_ld.dat'  'soYoutZup_seZinXdown_ld.dat'}
    linear_correction: 1
        pose_solution: 'optimize'
    optimize_fixtures: {'stage'  'sensor'}
Optimizing fixture poses:
    {'stage'}    {'sensor'}
source_fix_delta =
     0     0     0     0     0     0
stage_fix_delta =
  -1.1704e-06  -0.00036527   0.00015271  -1.4015e-05  -5.6628e-05  -5.5399e-05
sensor_fix_delta =
   6.0401e-05  -0.00014618  -0.00015106    0.0004906   0.00052564  -0.00054039
Position error (m): 4.63e-04 RMS, 9.18e-04 max.
Orientation error (radians): 4.86e-03 RMS, 1.02e-02 max
________________________________________________________________

Fixture optimization should of course only reduce the error, and is to some
degree going to squeeze out "real" error.  But 23% is quite significant.  One
thought is that calibration optimization is not directly minimizing the pose
error.

 ==> Also, the test data is explicitly different from the calibration data,
     since it has more points.  So seeing a difference is not surprising, and
     doing the fixture optimization at check time is a bit dodgy because it
     undermines the principle of testing on different data than the
     calibration.

I changed output_correction to do the fixture optimizations, which seems
useful, but only very marginally improved accuracy in check_poses() without
fixture optimization:
________________________________________________________________
Checking from: C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_30_premo_cmu
             cal_file: 'XYZ_tweak_hr_cal'
              variant: 'default'
             in_files: {'soYoutZup_seYoutZup_ld.dat'  'soYoutZup_seZinYup_ld.dat'  'soYoutZup_seZinXdown_ld.dat'}
    linear_correction: 1
        pose_solution: 'optimize'
    optimize_fixtures: {}
Position error (m): 5.92e-04 RMS, 1.23e-03 max.
Orientation error (radians): 4.99e-03 RMS, 1.08e-02 max
________________________________________________________________

Doing the check_poses() optimization gets basically the same result either
with or without optimization in output_correction:
________________________________________________________________
Checking from: C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_30_premo_cmu
             cal_file: 'XYZ_tweak_hr_cal'
              variant: 'default'
             in_files: {'soYoutZup_seYoutZup_ld.dat'  'soYoutZup_seZinYup_ld.dat'  'soYoutZup_seZinXdown_ld.dat'}
    linear_correction: 1
        pose_solution: 'optimize'
    optimize_fixtures: {'stage'  'sensor'}
Optimizing fixture poses:
    {'stage'}    {'sensor'}
source_fix_delta =
     0     0     0     0     0     0
stage_fix_delta =
    1.702e-06  -0.00035856    0.0001225   6.5302e-05    0.0001444  -0.00042197
sensor_fix_delta =
   3.6965e-05   -0.0001151  -0.00011487   0.00051922  -0.00049737  -1.8401e-05
Position error (m): 4.64e-04 RMS, 9.20e-04 max.
Orientation error (radians): 4.91e-03 RMS, 1.03e-02 max
________________________________________________________________
FWIW, it is barely detectably worse.

So the benefit of check_poses() fixture optimization is due to optimizing on
the actual test data, based on our ground-truth knowledge.  This is still
perhaps somewhat defensible, in that we do not have any definite source/sensor
coordinate system, and from a relative motion perspective we *could* choose
this particular fixed kinematics to get this result.  But a better way to
quantify the relative motion performance would be via the linearity tests.

So the very good results from cal_5_28_premo_rotated_dipole are in some part
due to the use of check_poses() fixture optimization on that data.  But
without the cp optimization, the results are really bad, due to motion in the
setup, probably mainly the 17 mrad change in Rx.  So we can't really do this
test "right" without retaking the data.

It is somewhat more defensible to reoptimize only the stage fixture in
check_poses() since we might deliberately vary this in our setup, and this is
not pulling as many DOF out of the error.  Ideally the source and sensor
fixture would not change, although in practice the sensor fixture is somewhat
unstable, and our source attachment to the source mover is also not that good.

It's possible that doing the calibration on the large data would give a better
calibration, but then we would need even larger, or otherwise different test
data, which is once again going to somewhat decrease measured accuracy.  I
don't want to go down that rabbit hole.  We already have a capability to make
the accuracy seem worse by using the source fixtures.

My thinking is that we want a dual characterization of accuracy, with and
without source fixtures.  The benefits of the rotated dipole configuration are
very unlikely to persist across source motion.


On the plus side, I am now pretty confident that I have not broken anything
with the calibration and test setup, since I am getting extremely similar
accuracy to what I had gotten on [4 June 21].


[9 Aug 21]

re. pose output rotation problem, with cal_7_30_premo_cmu test_script.m, every
run that includes soZoutYup has goofy huge error, and all of the others fine.
Or specifically, the 'ld'.  The 'source' seems sane.
 ==> Ok, pretty sure the 'ld' was taken in the wrong fixture.  The home pose
     coupling is not even vaguely the same between 'ld' and 'source'.  I guess
     it could be the wrong sensor fixture, not necessarily source.

 ==> Linear correction is now hurting accuracy with non-concentric XYZ_hr_cal
     also.

Linear correction was broken by the change to check_poses 'stage_coords'.
Correction can't be caculated in the stage coordinates.  I got this to work by
not using 'stage_coords'.  Still not seeing all that much benefit on this
data, but at least isn't hurting.  The non stage_coords path doesn't deal with
rotation error wrapping, but that won't matter for the linear correction,
which is only on translation.



We are still having lots of points where the 'optimize' pose solution does not
converge.  This throwing away "bad" points is pretty unacceptable for
performance evaluation, and we do need to solve the problem of how to
initialize the pose for realtime use.
 ==> Initializing to the Kim18 solution has fixed this, at least on this data
     (with nominally concentric source and sensor).


It seems that:
    cal_data/5_25_premo_rotated_dipole
    cal_data/cal_5_28_premo_rotated_dipole

Are the data where I have gotten the best calibrated accuracy (without source
fixtures).


Going back to cal_7_29_premo_dipole.

re. notes on [3 Aug 21] about quadrupole disappearing.  Since the data is
different, that is not in itself a problem.  But if the old calibration worked
*better* than the new one, then that is puzzling.  In the past, with the
non-rotated dipole, we did not usually get any pinned quadrupole to speak of,
which is more what we are getting with cal_7_29_premo_dipole.

The so_quadrupole calibration is really dragging on, despite failure to
improve the residual, and no obvious runaway DOF.  It looks like there are
very small moves happening in the dipole and quadrupole moments.


[6 Aug 21]

[Note that this below is with cal_7_30_premo_cmu]

Having some sort of problem with the soZoutYup source fixture testing, where
the position is good but the orientation is off 180 degrees or so, and this
does *not* seem to be due to simple angle wrapping.  FWIW, since we are not
including the source fixture motion in the initial state we are currently
getting really terrible initial state in this case, only just barely in the
correct hemisphere (after I added adding a hack to flip initial state when the
hemisphere is wrong).

Does this have to do with hemisphere ambiguity?  Is the forward kinematics
desired pose wrong?  Note that if there is magnetic ambiguity, then the
calibration will be fine if we have the wrong "desired" pose because we are
still generating the correct coupling.  Or *approximately* correct, in that
with a non-concentric source there is AFAICT not a perfect mirror symmetry,
although there is presumably still some pair of ambiguous poses.

This doesn't seem to be simple magnetic ambiguity, though, because that flips
the translation, but does not affect the orientation.

Maybe we still do not have the right source motion/source fixture transform?


I rolled back to the version of trans2pose which uses tr2angvec() because the
logm version was not working in some cases.  I don't know if whatever problem
I thought I was having is going to reappear.

I moved the 'stage_coords' feature into find_pose_errors(), and it *seems* to
be working there.  The problem with the soZoutYup fixture is still there
without the stage_coords transform.  The rotation difference does not seem to
be a wrapping thing, the axis of rotation is in a very different direction,
not sign flipped.


kim18 concentric solution is working much worse than it did on [17 Jun 21],
and the linear correction does not work at all.  Presumably something to do
with the source fixture or options modifications.


[5 Aug 21]

Getting a bit overwhelmed with all of the calibration variants I am testing,
what their parameters are, and which output files they correspond to.  So I've
created a test_script.m (so far only in cal_7_30_premo_cmu) which will
generate all of the calibrations from a base calibration, and run tests.  This
will enable reproducible results.



[4 Aug 21]

________________________________________________________________
'C:\Users\robma\Documents\Work\ilemt\cal_data\cal_7_29_premo_dipole'
>> cp=check_poses();
                     ishigh: 1
            valid_threshold: 1e-05
          optimize_fixtures: {}
                     moment: 0.05
              pose_solution: 'optimize'
                 hemisphere: 0
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 11
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
         rot_xyz_exaggerate: 300
               stage_coords: 1
                    issweep: 0
                   cal_file: 'XYZ_hr_cal.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'soYoutZup_seYoutZup_ld.dat'  'soYoutZup_seZinYup_ld.dat'  'soYoutZup_seZinXdown_ld.dat'}
1 invalid points with residual > 1e-05.
bad_points =
        1367
Position error (m): 4.55e-04 RMS, 1.69e-03 max.
Orientation error (radians): 1.55e+00 RMS, 6.28e+00 max
trans_err_rms =
   0.00017687   0.00035153   0.00022884
rot_err_rms =
        1.092      0.10177       1.0912

>> disp(cp.calibration.options)
              source: 'dipole'
              sensor: 'premo'
            cal_mode: 'XYZ'
    base_calibration: 'XYZ_hr_cal_old'
              ishigh: 1
           normalize: 1
      pin_quadrupole: 1
          concentric: 0
        correct_mode: 'none'
        sensor_signs: [1 1 1]
        source_signs: [1 1 1]
     sensor_fixtures: {'seYoutZup'  'seZinYup'  'seZinXdown'}
     source_fixtures: {'soYoutZup'}
       data_patterns: {'md'}
            in_files: {'soYoutZup_seYoutZup_md.dat'  'soYoutZup_seZinYup_md.dat'  'soYoutZup_seZinXdown_md.dat'}
            out_file: 'XYZ_hr_cal'
            optimize: {'d_so_pos'  'd_so_mo'  'd_se_pos'  'd_se_mo'  'st_fix'  'se_fix'}
              freeze: {'d_so_z_gain'  'd_so_y_co'  'd_se_y_co'}
          iterations: 200

>> print_calibration(cp.calibration)
                d_source_pos                            d_source_moment                             d_sensor_pos                             d_sensor_moment          
    _____________________________________    _____________________________________    _________________________________________    ___________________________________
     0.046218    -0.0012051             0      0.93063    -0.0084566             0     0.00015939     8.3417e-05              0      0.15915    0.0001556            0
    0.0023748      0.046346             0            0       0.94769             0     6.2236e-05     1.8204e-05              0            0      0.15828            0
    -0.043866     -0.042817             0    -0.023946      0.007795             1    -0.00015015    -0.00017581              0    0.0022674    0.0020203       0.1627
Source fix: [0.00381 0.00333 -0.00605 0.00969 0.00974 -1.59302 ]
Stage fix: [-0.00050 0.24294 0.00575 -0.00312 0.00326 0.01568 ]
Sensor fix: [-0.00022 0.00019 -0.00021 -2.20115 -2.23164 -0.00009 ]


w/o linear correction:
Position error (m): 5.62e-04 RMS, 1.81e-03 max.
Orientation error (radians): 1.55e+00 RMS, 6.28e+00 max
________________________________________________________________


Most recent comparison data with non-rotated corner dipole seems to be
[12 May 21], when I got:
    Position error (m): 5.65e-04 RMS, 1.45e-03 max.
    Orientation error (radians): 7.40e-03 RMS, 1.92e-02 max

With non-rotated corner dipole Premo (no linear correction).  Comparing to the
new result (also without linear correction), RMS is about the same, max rather
worse.  So these results are about what we would expect.  The new source
fixture setup and code changes have not made anything worse.  This is a
regression test, and is not using any source fixture data.

See [27 May 21], there was a quite significant improvement with the rotated
corner dipole (no linear correction):
    Position error (m): 3.51e-04 RMS, 8.40e-04 max.
    Orientation error (radians): 5.55e-03 RMS, 1.18e-02 max

So with the non-rotated dipole we can't expect the 2.28e-04 RMS, 4.98e-04 max
that we got on [4 Jun 21].

We can't expect the same accuracy with multiple source fixtures as we get with
just one.

Ideally we'd like to come up with a calibration that covers multiple fixtures
without greatly compromising the performance in the nominal orientation.  One
way to do this may be to calibrate source parameters with multiple fixtures,
then do the final calibration on sensor parameters only, with single source
fixture data.  This way the linear correction would only apply to the nominal
orientation, which would increase its effectiveness, but we should not use it
outside of that quadrant.

Also reasonable would be to have two calibrations, one which is all-quadrant,
and one which is optimized for the nominal orientation, and then report
seperate accuracy stats.


Pinned quadrupole with cal_7_30_premo_cmu gave a fairly "pretty" quadrupole,
with roughly equal negative diagonal.  check_poses() accuracy was negligibly
better than dipole-only (compared with linear correction, and without using
any source fixtures in the test).  So adding the source fixture/quadrupole
calibration did not hurt home hemisphere performance.  We would expect the
benefit of multi source fixture calibration the appear only when those
fixtures are tested.

I tried non-pinned quadrupole with cal_7_30_premo_cmu, using just the source
fixtures.  The source fixture Z offset was running away.  Not optimizing the
source fixture stopped the runaway, but the result is still barf.



[3 Aug 21]

Working with cal_7_29_premo_dipole, and seeing some confusing stuff.  I started
with base calibration from cal_7_21_premo_dipole, which had nontrivial
quadrupole, then the XYZ cal with that in place.  Then I went on to redo
quadrupole cal, and the quadrupole largely disappeared.  But after
so_quadrupole_all optimization using both the _source and _md data, this
calibration is not working as well as the XYZ_hr_cal (which had the old
quadrupole).

One thought is that there is a lot more sensor fixture data than source
fixture, and this may be swamping the calibration.


I added d_so_z_gain to the state so that the source Z moment can vary from 1.
I discussed this for partitioning source and sensor gain, but it seems like it
should help with quadrupole calibration also, since it avoids an interaction
with the sensor parameters.  Previously we needed allow the sensor gain to
vary to compensate for the source Z quadrupole, since the Z dipole was fixed.


[30 July 21]

Ok, here's one more take on how to notate the fixture orientations.  +Z-Y+X
was completely nonintuitive, and also I got things inconsistent between source
and sensor.  This goes back to the in/up convention I first used for the
source fixtures.

Here's how it works:
 -- "out" is a synonym for fixture +Y.  Now the source fixture uses the same
    Rz orientation as the stage (and sensor fixture), so "out" is in the same
    direction for both.
 -- "up" is a synonym for fixture +Z.
 -- We represent a rotation by which mover axis is "out" and "up.  If the
    out/up axis is negative, then we use in/down.
 -- out/in always comes before up/down.  So YoutZup, YinZup, etc.

So ZoutYup means:
	Mover		Fixture
____________________________________
	+Z (Z)		+Y (out)
	+Y (Y)		+Z (up)
	+X		-X	(implied by right hand convention)

To me this is fairly intuitive, but it semantically works basically the same
way as the +/- axis mapping.  For more discussion of the fixture convention,
and data collection plans (input file and fixtures), see:
    ilemt/cal_data/input_patterns/test_plans.txt 


[29 July 21]

It would be nice if we could more explicitly separate the source and sensor
calibration so that we could swap one or the other without having to start
over from scratch, ideally a drop-in replacement with either no serial number
dependence, or with calibration data that is paired to that source/sensor.

The one big obstruction is the system gain.  Sources and sensors vary in their
gain, and we need to factor this gain to the appropriate place.

If source and sensor were calibrated to physical units, then this would not be
a problem.  But this would be a whole new undertaking, and could introduce
extra error.

Another approach is to standardize the gain to a particular source and sensor.
One source (corner dipole) gets the Z moment forced to 1.  Calibrating a
different source wrt. the same sensor gives a change in the gain which we
attribute to the source.  The sensor calibration is entirely frozen, and we
allow the source Z gain to change.  (Source Z gain is not currently
represented in the state, would need to be added.)  Likewise, to calibrate
another sensor we change the sensor and hold the source frozen.

I guess the key idea is that we need to permit (just one of) either source or
sensor gain to vary during calibration.  It isn't required that any of the
gains be 1.  We calibrate a new source using the standard sensor, with its
already established fixed calibration.  We calibrate a new sensor using the
standard source and its fixed calibration.

Although this is cringe from a metrology perspective, we are implicitly
referring back to a "gold standard" source and sensor.  For max
interoperability we want the reference to be not just the same design, but the
exact same unit.  At the moment we are not going to get far enough down the
road of source/sensor interchangability that this needs to be worried about.
I'm hoping that the two-sensor bar method can be used to calibrate out minor
variations in a particular source/sensor configuration.


[27-28 July 21]

My efforts to visualize the RPY for the source fixture XYZ axis mappings
failed, so I went and implemented in code, and now it seems to be more or less
working with multiple fixturings.  *#$&*^#$ Euler angles, I spit on thee.
[2 Aug 21, I think real problem is that I didn't appreciate that the source
and sensor fixtures are inverses of each other with respect to the notation.]

I worked through up to source quadrupole with cal_7_21_premo_dipole and the
four source fixturings.  This is with the pinned quadrupole on the non-rotated
dipole source.

________________________________________________________________

                d_source_pos                           d_source_moment                            d_sensor_pos                              d_sensor_moment           
    _____________________________________    ___________________________________    _________________________________________    _____________________________________
     0.045831    -0.0011063             0       0.9481    0.0021454            0     0.00014469    -6.3211e-05              0      0.15665    0.00033138             0
    0.0034569      0.043343             0            0       0.9508            0    -3.0316e-05    -1.2321e-05              0            0       0.15574             0
    -0.038597     -0.035288             0    -0.024519     0.010004            1     0.00011242     5.4172e-05              0    0.0025424     0.0019528       0.16043
    q_source_pos              q_source_moment              q_sensor_pos    q_sensor_moment
    ____________    ___________________________________    ____________    _______________
    0    0    0       -0.1046    -0.085138     -0.10047    0    0    0       0    0    0  
    0    0    0       0.10441     -0.96208     -0.18794    0    0    0       0    0    0  
    0    0    0     -0.045446      0.20453      -1.4928    0    0    0       0    0    0  
Source fix: [0.00338 0.00331 -0.00596 0.01302 0.00162 0.00875 ]
Stage fix: [0.24783 -0.00591 0.02044 -0.00113 0.01712 -1.57227 ]
Sensor fix: [-0.00014 0.00038 -0.00015 -2.20144 -2.22831 -0.00060 ]

Optimization stopped because the relative sum of squares (r) is changing
by less than options.FunctionTolerance = 1.000000e-08.

cal_residue =
    0.0085162
________________________________________________________________


I thought that maybe this pattern of the q_source_moment was something I had
seen before, but looking back, no.  Result from [2 Jun 21] rotated corner
dipole is that the pinned quadrupole moment is nil.  Prior non-pinned results
were physically implausible and highly suspect.

The predominantly diagonal and negative quadrupole is something we have seen
before, eg. [3 Jun 21] with the CMU concentric source, pinned.  The negative
quadrupole means that at short range the field is weaker than the dipole model
predicts.

I don't have an explanation for why the quadrupole magnitude varies across
axes and is much lower on X.  Frequency dependence of proximity effects (like
eddy current loss) could be a factor.  But I would expect that to be roughly
linear with frequency, yet the jump from X to Y (7.5 kHz to 10.5 kHz) is way
out of line with that.  I had been thinking that axis asymmetry was due to
varying observability of the quadrupole, given the single source fixturing.
But now we have multiple fixturings.  Perhaps results will change with careful
mechanical setup.

Note that this quadrupole magnitude (with non-rotated corner dipole) is still
pretty small.  At 170mm radius:
________________________________________________________________
>> p1
p1 =
            1            0            0         0.17
            0            1            0            0
            0            0            1            0
            0            0            0            1

>> norm(forward_kinematics(p1, d_cal))
ans =
      0.52877

>> norm(forward_kinematics(p1, cal))
ans =
      0.53321

>> 1-0.52877/0.53321
ans =
    0.0083269
________________________________________________________________

where cal is the new source quadrupole cal, and d_cal is the same, but with
the quadrupole term zeroed.  So less than 1% even at extreme close range.
(But the relative change in off-axis components is significantly bigger, might
affect pose solution disproportionately, IDK.  Sensitivity.)


[23 July 21]

Working on adding the source rotation fixture to the Matlab code.

Note that we now have the source fixture coordinates, as distinct from the
source coordinates.  So we need labels on the baseplate and the moving box
(mover).  In the current setup (non-rotated dipole source) the coil is aligned
with our nominal axes, so there is minimal difference, but with when the
source is not aligned with the fixture, then source fixture transform has
significant rotations.

The source fixture only supports 4 orientations, but each axis gets to point
parallel to the source->sensor displacement, and each gets to point normal to
the sensor also.  This should allow pretty good mapping of the field from the
perspective of the dipole+quadrupole approximation.

I'm going to represent the source motion orientations by which axes are
aligned.  The ordering is defined by fixture axis, so for example +Z-Y+X means
that source fixture X is aligned with mover +Z axis, and so on.  Then we have:

[### ******** the Euler angles are wrong, see [27-28 July 21]]
		      fixture axes	source motion
	old name	 X Y Z		RxRyRz (ZYX Euler order)
________________________________________________________________
	(no rotation)	+X+Y+Z		+000+000+000
	XupYout		+Y+Z+X		-090-090+000
	XupZout		+Z-Y+X		-180-090+000
	Z90		-Y+X+Z		+000+000+090


Mappings for our sensor fixturing (rotation with respect to stage
coordinates):  
		      fixture axes	sensor motion
	old name	 X Y Z		RxRyRz (ZYX Euler order)
________________________________________________________________
	Z_rot		+X+Y+Z		+000+000+000
	X_rot		+X-Z+Y		+090+000+000
	Y_rot		-Y-Z+X		+090+090+000

Note that in null pose the stage coordinates may be rotated WRT to sensor (by
the sensor fixture transform), so the sensor axes don't align with the sensor
mover axes.


I don't have the exact numbers, but it seems that with the multiple source
fixtures, the benefit of the quadrupole is greater, but the overall
calibration residue is also somewhat bigger.  This is pretty much what we
would expect.  Shouldn't over-interpret these results until I have the source
fixture setup finalized, though.




[20 July 21]

Looked into KFR and FFTW DSP libraries. KFR seems to have some ongoing
maintenance.

FFTW is only bare FFT, so would need to find/write code for windowing,
STFT, etc.  It does seem to be the standard for fast FFT, but the
interface is not pretty.

KFR has FFT windows, and some other interesting utilities, good C++
feature use.  Clang is the preferred compiler for KFR, FFT is maybe
broken in gcc.

The KFR vector type univector<> seems like it would work for basic
buffer management, but the places where we are using multi-dimension
arrays in Labview, would have to think about the best representation,
especially for demodulated signals.

Maybe transition to Eigen representation after demodulation.  Eigen
doesn't have more than 2D matrices, but we are largely single-sample
processing after demodulation, so that might not be a big
deal. Eg. for "High carrier amplitudes", out of 4D we lose the sample
dimension, and carrier x channel is a coupling matrix.  So we just
have card as additional.  It seems reasonable to have each card be a
distinct instance, since there is really nothing in common between
processing across cards.  So we would have a vector of cards.  This
also neatly supports having variable numbers of cards configured.

Maybe we want a wrapper for high/low rate coupling pairs. (Usually
high at low.)  A card is clearly a mutable instance, while we do want
to have pure values we can pass around.

So, toolchain:
  c++ 17
  CLang
  CMake
  Eigen
  KFR

Eigen seems to have a number of optimization libraries and library
bindings built on it.  Possibly Ceres NLSQ optimizer would be useful for
pose initialization.

 -- Need some kind of configuration library.  Boost "Property Tree"?
    Many things parameterized in Labview will be code constants or
    simply hardcoded.

    
For now, keep the existing ilemt_ui.vi and ilemt_server, and make new
ones for the realtime mode.



[19 July 21]

GNU Radio:
 ==> I don't think GNU Radio would work.  Real-time latency is a big
     problem.  GNU Radio is not designed for that.  There is some kind
     of real-time scheduling, but we are not that great a fit for GNU
     Radio in the first place.  What we are doing is already
     prototyped, and the our block synchronization avoids most of the
     dataflow and synchronization problems that the dataflow model
     handles. 


Kind of nervous thinking about runtime for all the pose solution work
with the UKF.  For one thing, the forward kinematics could be a pretty
big overhead, especially after duplicating for the UKF.  But we should
be able to flatten out some layers, and vectorize to some degree:
 -- We are always transforming by the same P.
 -- We can support quadrupole and other multi-dipole arrangements much
    as we currently do, building a list of all the dipole pairs.
 -- The dipole pair list (eg. so/se positions and moments) is a
    constant function of the calibration, so we don't have to dig into
    the calibration struct if we have this cached.
 -- We are only doing one pose solution (per card).  This is at least
    9x less than the number of demodulations and output filters.

The Kim18 method should be quite fast, and I could implement that
first.  It's going to be much simpler also.  But then we don't have
any Kalman filter unless we implement that separately.

I think we can get rid of the per-coupling KFs and roll that into the
main UKF.  The main place where this has value is with the noise
estimate (which is kind of broken at the moment due to distortion in
the guard channels).  It's more useful to do the KF in the output
(pose) space, since we can more easily apply physical constraints such
as max acceleration.  Need to look at how the current reference works,
since we are using the KF to suppress reference noise.  (There would
be other ways.)

Demodulation and filtering:
 -- We process at 1.5 ksps, but for the output filters, we only
    process one output sample at a time. (18 channels/card for complex
    coupling.)
 -- And *one* FFT per input, cards*3 + 3 for current, so 15 FFTs max.


What do we currently actually do in signal processing?
 -- FFT
 -- Noise estimate & coupling Kalman filter
 -- Distortion + hum filters.  (Hum not currently working due to clock
    frequency.)
 -- Signal normalization by reference
 -- Low rate demodulation
 -- Carrier generation

This is really not all that complicated, a lot of the ilemt_ui
complexity comes from the user interface and instrumentation, and the
system/glue code: getting data, splitting and joining data streams.


See [31 Mar 21] in notebook.txt for more realtime code ideas.


[15 July 21]

The requirements I gave in the ILEMT proposal were:

Bandwidth (Hz)			500
Samples/second			1000
Latency (ms)			1.5
Noise (um RMS, 1-Hz bandwidth)	0.15
Figure of merit (rtHz/um)	150
Accuracy (um RMS)		<400 (or 1% of motion)
Workspace (mm/degree)		>200 mm / any
with sensor size (mm, volume)	15mm

The speed parameters remain to be determined after real-time solution
and tuning, but 1500 vs 1000 samples/s should help.  At least over the
stage workspace with linear correction, the accuracy is well better,
228 um/0.6%.

I think we are also well better than the speed/noise specs (figure of
merit), though I don't yet have numbers for noise in the 3D position
solution.  I don't seem to have much recent 1DOF noise measurement,
but on [25 Feb 21] I was getting:
	Range (mm)	RMS noise >0.2 Hz
	130		80 nm
	240		490 nm

I spec'd noise in 1 Hz bandwidth, so if the bandwidth is 100 Hz, then
the 1 Hz 1DOF noise is 8 nm - 49 nm, with FoM 1250-204.  We expect to
lose in the ballpark of 3*sqrt(3) in the 3DOF solution, giving FoM
240-40.  Probably the bandwidth is somewhat higher also, I was aiming
for 300 Hz in tuning.  So we can defintely expect to exceed the
requirement at short range, and plausibly even at 200 mm.  The
SNR/range also depends on the source/sensor.



[12 July 21]

C++ library resources:
 -- Eigen: matrix and linear algebra.  There are other options, but Eigen
    seems to be popular (used in ROS), and makes clever use of C++ for
    expressive power and efficiency.  Not a complete array package because it
    has only vectors and 2D matrix.
 -- Boost: many highly generic programming extensions, some domain specific
    things.  May be useful: Networking/IO, config files, some
    datastructures/containers, threads/multiprocess.  Ring buffer?
 -- Signal processing?  https://www.gnuradio.org/  FFTW C FFT library.  KFR is
    native C++, claims to have fast FFT.  There are no super-popular DSP
    libraries outside of FFTW.  Often the linear algebra libraries (Eigen,
    Armadillo) are recommended.  And GNU Radio, which seems worth checking out,
    possibly the high-level graphical interface is usable also.  One need is
    for buffer management integrated with whatever other packages are in use.
    KFR seems to have pretty good integration with STL vector/array.  

 ==> Remember we need ARM support

GNU Radio is Python oriented for scripting, but seems to be implemented in
C++, and accessible at that level.  Possibly the Python scripting would not be
terribly inefficient if it is only running at the block rate, and good for
prototyping.  GNU Radio has a particular focus on Zynq/Zedboard.  Supports a
cross-compilation model:
https://wiki.gnuradio.org/index.php/Install_and_configure_SDK
Hookin with OpenEmbedded, which is a build tool.

GNU Radio seems particularly well suited for translating from the Labview
dataflow model.


[17 Jun 21]

That was a fun one.  Turns out that with cal_5_19_premo_cmu, the
kim_cal.coupling_gain.^2 is approximately 1/(2*pi), to within a couple
percent.  So adding the 1/(2*pi) gamma_fudge to kim18() gave approximately the
correct radial distance, but we were actually working with a wrongly scaled
coupling matrix.  The error was that I had gotten the interpretation of
coupling_gains wrong (eg. in the comment in cal2kim18), and we need to divide
by coupling gains to convert coupling -> S_.  Multiplying twice is where the
gain^2 term came from.

I can't recall another time where I've had the wrong procedure, by pure
cooincidence, give a result that was so close to correct.

Now the kim18 method is giving quite similar results to optimization (using
the concentric calibration), and also the linear correction is working.

The correction is giving much the same accuracy regardless of whether the
correction is computed using the same or different method.  This is not
surprising because the methods are giving basically the same result.  The
errors that it is correcting come from the inadequacies of the magnetic model,
which is the same in both cases.

Accuracy with both solution methods, and linear correction (using same
method):
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
              pose_solution: 'kim18'
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
         rot_xyz_exaggerate: 300
               stage_coords: 0
                    issweep: 0
                   cal_file: 'XYZ_concentric_hr_cal_DLT_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
Position error (m): 4.43e-04 RMS, 9.82e-04 max.
Orientation error (radians): 7.64e-03 RMS, 2.02e-02 max
trans_err_rms =
   0.00024632   0.00023611   0.00028259
rot_err_rms =
    0.0038541    0.0048778    0.0044486


>>check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
              pose_solution: 'optimize'
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
         rot_xyz_exaggerate: 300
               stage_coords: 0
                    issweep: 0
                   cal_file: 'XYZ_concentric_hr_cal_DLT_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
8 invalid points with residual > 1e-05.
bad_points =
  Columns 1 through 6
        1276        1291        1301        1311        1316        1343
  Columns 7 through 8
        1357        1367
Position error (m): 4.41e-04 RMS, 9.60e-04 max.
Orientation error (radians): 7.61e-03 RMS, 2.01e-02 max
trans_err_rms =
   0.00024037    0.0002372   0.00028311
rot_err_rms =
     0.003828    0.0048802    0.0044144
________________________________________________________________

So the accuracy difference of the two solutions is nil.

But if we use the non-concentric model with optimize method:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
              pose_solution: 'optimize'
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
         rot_xyz_exaggerate: 300
               stage_coords: 0
                    issweep: 0
                   cal_file: 'XYZ_hr_cal_DLT_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
12 invalid points with residual > 1e-05.
bad_points =
  Columns 1 through 6
        1270        1271        1276        1291        1296        1311
  Columns 7 through 12
        1316        1348        1352        1353        1357        1377
Position error (m): 3.17e-04 RMS, 7.50e-04 max.
Orientation error (radians): 5.72e-03 RMS, 1.29e-02 max
trans_err_rms =
   0.00017653   0.00018174    0.0001905
rot_err_rms =
    0.0030535    0.0036072     0.003219
________________________________________________________________

Then we get a significant improvement.  If we go and use this calibration with
kim18:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
              pose_solution: 'kim18'
          linear_correction: 0
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
         rot_xyz_exaggerate: 300
               stage_coords: 0
                    issweep: 0
                   cal_file: 'XYZ_hr_cal_DLT_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
Position error (m): 3.54e-03 RMS, 4.99e-03 max.
Orientation error (radians): 3.53e-02 RMS, 6.73e-02 max
trans_err_rms =
   0.00071938    0.0029401    0.0018424
rot_err_rms =
      0.01421     0.025311     0.020066
>> output_correction(cal_options)
Wrote XYZ_hr_cal_DLT_corrected
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
              pose_solution: 'kim18'
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
         rot_xyz_exaggerate: 300
               stage_coords: 0
                    issweep: 0
                   cal_file: 'XYZ_hr_cal_DLT_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
Position error (m): 5.62e-04 RMS, 1.33e-03 max.
Orientation error (radians): 3.53e-02 RMS, 6.73e-02 max
trans_err_rms =
   0.00031837   0.00029812   0.00035458
rot_err_rms =
      0.01421     0.025311     0.020066
________________________________________________________________
The result is appalling using the non-concentric calibration with kim18, but
adding the kim18 linear correction helps hugely.




[16 Jun 21]

I got the kim18 closed-form pose solution to where it seems to be basically
working.  But even when using the exact same concentric calibration, the
accuracy is about 10x worse than using nonlinear optimization.  Possibly
there is still a bug, or there is a numerical difficulty, maybe due to the
particular fixturing, or something.

 ==> SVD is not optimizing, fk_kim18 agrees precisely with our forward
     kinematics.  It likes our solution better than its own.

The rcond() numerical condition of the matrices Y_, S_, N_ and M_ all seem
fine.  To within 1e-16 or so the SVD result satisfies the SVD definition, and
A = inv(inv(A)) for M_, N_.

Rstar_ is wrong too, not just the translation.  This pares us down to
basically three lines, and rules out being caused by the mu_/gamma_ fudge
issues.

Error occurs even though we directly pass the kim18() result to fk_kim18(),
without going to pose vector and back.


[7 Jun 21]

I implemented 3D view of the rot->trans errors in perr_workspace_vol().  This
is kind of interesting, in that it lets you see the trans->rot error better in
non-sweep data.  The error vector spray does trend in different directions at
different rotations.  But it rather seems that more variation in error
direction is due to translation.  With the sweep data, this is another way to
see the 4x rotation effect in the cross coupling.

I didn't notice it before, but in the trans->trans plot you can also arcing
flow lines in the error vectors.  Maybe this is the expected polar measurement
effect that tangential error is larger than radial?  But this flow is around
the center of the of the workspace, rather than the center of the source,
which is more what I was imagining.  The calibration and correction do of
course center the errors here.

The rot->trans plot also reminded me that we don't have many rotations in the
calibration data.  This may be affecting our ability to identify
eg. quadrupole terms.  It might work better to add some axis sweeps to the
cross-product mesh, to get finer gradations without a huge blowup of the
points.  eg. denser rot sweeps at a few of the points near the source because
deviations are stronger at short range.  And then at least one denser
translation sweep, perhaps in the radial direction, to get at the details of
the radial response.  These don't need to be nearly as close spaced as the
axis sweeps, but say at least 20 points.

It is also fairly obvious that the quadrupole can't very well approximate the
response of a cube coil.  It can tweak the radial response and perhaps
usefully model off-axis imperfections, but it can't model the systematic lack
of axial symmetry from the square coil.  It would likely work better to use a
square pattern of dipoles or of dipole+quadrupole.

But, as noted on [4 Jun 21], our accuracy is maybe pretty OK, and it is time
to start wrapping up the calibration effort.

Materials for possible stage pole stiffening:
8548K25, Structural FRP Fiberglass Square Tube 5 Feet Long, 3" Outside Width x 3" Outside Height 
8993K14, Multipurpose 304 Stainless Steel 90 Degree Angle 1/8" Wall Thickness, 1-1/4" High x 1-1/4" Wide Outside

We can stiffen the lower part of the pole with stainless, and also go to a larger
square pole.



[4 Jun 21]

Summary:
 -- Switch to DLT linear correction
 -- Best accuracy so far with any sensor/source, using Premo/rotated dipole.
    Position error (m): 2.28e-04 RMS, 4.98e-04 max.
    Orientation error (radians): 5.99e-03 RMS, 1.12e-02 max


So it seems that the linear correction was not particularly helping with
trans<->rot couplings (which might partly come from eg. Rz runout), since we
get similar results with the "skew" model.  But this could still possibly be
correcting for translation errors in the stage.

I had been thinking that we could not detect linear scale error because there
is no absolute scale reference, but I think with the sensor rotations we can
probably detect unequal scales on XYZ, and non-orthogonality.


Ok, I figured out how to get the general linear transform that I was trying to
get with my pseudo-inverse "skew" method.  It was not in fact inferring any
skew or trapezoid.  I was misinterpreting it because the matrix was transposed
for row vectors.  So it was the skew terms that were zero, and the translation
terms were small (but nonzero).  Yet this did work better than the 3x3
transform, which I suppose is that by dropping out the residual translation
error, we weren't pushing that into the 3x3.  The 3x3 part has significant
non-orthogonal components either way, which was significantly constributing to
the benefit.  The accuracy as measured by check_poses was completely
unaffected by the non-3x3 transform(4, :) and transform(:, 4).  The first does
not matter because we drop out translation, and the second was effectively
zero.

But using a general projection transform, of which a homography or perspective
projection matrix are special cases, we can get the skew/trapezoid terms.  A
simple method is the "Direct Linear Transformation":
    https://en.wikipedia.org/wiki/Direct_linear_transformation

I found a matlab script which implements this, now in
'ilemt/matlab/utils/dlt.m'.  As with the more widely discussed case of
projection from 3D to 2D, or 2D to 2D, after applying the transform to the
one-padded vector, you re-normalize the result by dividing by the last
element.  This allows those skew/trapezoid effects to get in.

With this, using rotated corner dipole/Premo: 
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 11
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
               stage_coords: 1
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/XYZ_hr_cal_DLT_corrected.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880
Optimizing fixture poses: both
source_fix_delta =
  -0.00038159  -0.00014553   0.00026127    0.0018193  -0.00064629   0.00039965
sensor_fix_delta =
  -9.3869e-05   2.0265e-05   -0.0001247    0.0008153   0.00022489  -5.9518e-05
Position error (m): 2.28e-04 RMS, 4.98e-04 max.
Orientation error (radians): 5.99e-03 RMS, 1.12e-02 max
trans_err_rms =
   0.00014154   0.00012704   0.00012502
rot_err_rms =
     0.002614    0.0033788    0.0041967
________________________________________________________________

With translation, compared to 'skew', this is 5% better for RMS and 12% better
for max.  Rotation is unaffected.  Or 27%/56% RMS/max compared to dipole-only
with no output correction.  'DLT' vs. 'skew' is not a big improvement, but
being tied to theory, and not purely ad-hoc, is a big advantage for
publication.  There is no reason not to do DLT.

Looking at the check_poses error-vectors plot it subjectively seems that we
are squeezing out all the linearish errors, so that the error vectors are
spread radially around each point without tending in any XYZ direction.
Compared to without correction, the off-axis trans->trans cross coupling is
also considerably improved, giving overall reduced size of the error-vector
bunch.  In the axis sweep the YZ on-axis linear INL is considerably reduced,
giving a pretty curvy INL with little overall slope.  There is still a bunch
of slope on X, though reduced compared to no linear correction.  My guess is
that while the X transform does not seem the best at YZ=0, across the full
workspace it is a good compromise.  The bigger reduction in max error suggests
it is particularly helpful at the edges of the workspace.

Given the circular spray of the error vectors it is tempting to think that the
residual translation error is mainly rot->trans coupling.  That the vectors
rotate definitely shows that that the error process is rotating with the
sensor.  That is, there is a significant sensor-referred error.  It is not
necessarily the case that our error vectors would rotate.  The rotation has to
be a sensor error (or a fixture error), because rotating the sensor with the
source->sensor translation held fixed is not going to give any change in field
at the sensor.  Any rotational nonideality in the sensor will also contribute
to errors varying across the translation workspace, since translation does
cause rotation of the field at the sensor.  This kinematic
translation->rotation effect is much larger than it was with the ASAP optical
measurement because the magnetic field is curved.

But the diameter of the splatter circle can be influenced by other things,
such as off-axis trans->trans coupling.  If the error did not rotate, then we
*might* be able to absorb it into the calibration or linear transform, but not
necessarily.

So, several thoughts on the linear correction:
 -- Does this work with other source fixturings?
 -- Is this compensating errors in the ground truth?
 -- A major virtue of the dipole+linear calibration is efficient real-time
    implementation. 
 -- We could generalize to incorporate source rotation by finding multiple
    rotation-specific transforms and interpolating between them.  This is more
    tractable than a brute-force LUT for the entire 6DOF pose space.
 -- Possibly we could also decompose sensor-referred error from the overall
    error, and correct in a sensor-centric coordinates, such as polar.  This
    would further reduce dimension of the correction vs. a brute-force sensor
    lookup.

FWIW, comparing to the ASAP_TIM09 paper:
    Fig. 15 shows the position error when the probe undergoes  [+/-] 1 cm
    translation.  Error is 1.6% of translation, and is exaggerated
    30x for clarity.  When ±20 degree rotation is introduced, the worst case relative
    error measured throughout the workspace is 6.5% of angle and 2.7% of
    translation.
    [This is max trans->trans and rot->rot INL, sum of on-axis and off-axis,
    also trans INL + rot->trans INL.]

    We measured the apparent translation due to a 1 degree rotation and the
    apparent rotation due to a 3 mm translation.  The worst case values across
    the workspace are 21 um/ degree and 0.36 degree/mm.  Fig. 16 shows the
    angular error as the probe undergoes [+/-] 1cm pure translation.  The peak
    error is 1.2 degrees.
    [This is the max trans<->rot DNL and max trans->rot INL]

So, in summary:
    trans->trans: 1.6% (over +/- 1cm)
    rot->rot: 6.5% (over +/- 20 degrees)
    rot->trans: 21 um/degree
    trans->rot: 0.36 degree/mm.

Compare to the current ILEMT axis sweep:
    trans->trans: around 0.6% max (over +/- 5 cm)
    rot->rot: around 0.3% max (over +/- 90 degrees)
    rot->trans: 7.4 um/degree
    trans->rot: 0.003 degree/mm.
[I have 'around' because the on-axis DNL is split across XYZ components, with
the total not computed.]

It's true that after adding the PSD linearization, and the stage calibration,
I improved the ASAP accuracy a lot, but this was never published.  But with
this comparison, the ILEMT angular accuracy is *much* better, and the linear
accuracy is better.  The improvement in trans->rot is 100x.  And we are
testing a 5x larger translation workspace, and 9x larger rotation.  So, even
if the calibration breaks down outside this workspace, we are already better
than ASAP.

IIRC, the final ASAP trans->trans (no rotation) performance was something like
0.2%, which is several times better.  But if you add any rotation (which is
not much affected by the sensor linearization), then things deteriorate
rapidly.  eg. 0.2% over 1mm is 20 um, but a 1 degree rotation also causes this
error.

The probe changes, especially bare LED, probably significantly improved the
rot->trans coupling, IDK.

So, we really can't use ASAP as "ground truth".  It's useful to for a
high-speed comparison, but it really isn't more accurate.  It's also a
redundant measurement which can highlight failings of the magnetic tracker
such as metal interference.

I could re-characterize ASAP accuracy, but that would be a fair amount of work
for unclear benefit.  If I am going to publish the simultaneous ASAP
comparison, then I really should do this, using the current stage setup.


Planning:

Need to get a handle on how the current calibration will generalize over
source rotation.  If we have an OK story here, or if we can get one by
calibrating across source rotations, then we are done with accuracy.  It would
be acceptable to have worse error across a large source workspace, as long as
the linear correction works over the kind of workspace that we need for
microsurgery.

So far as the engineering of ILEMT, once we have a working calibration model,
to get a working system all we absolutely need is the real-time pose solution.
This also implies an API for getting the data out, and converting ilemt_ui to
work remotely.

For engineering nicety we would want to take on things like duplicating the
hardware, dealing with calibration across multiple source/sensor
configurations and specific source/sensor instances, and documentation.  Given
other priorities (especially publications) it is not clear to what degree I
can actually do this in the time remaining.

Then there is publication, and possible more novel research contributions.
This is very important for possible future funding.

I can continue some degree of wrapping-up on my own time after funding runs
out, but the possible effort is limited, and not sure how much I will want to
do this.


[3 Jun 21]

Summary:
 -- Linear "skew" correction avoids problems with angle wrapping by only
    using the translation.  Dipole + skew with rotated corner dipole/Premo is
    giving our current best results, pos error 2.40e-04 RMS, 5.63e-04 max.
 -- With cal_5_19_premo_cmu, cmu-concentric source, the pinned source
    quadrupole is working ok.  This plus skew correction gives the best result
    on this data (but not as good as rotated corner dipole/Premo).

I implemented "skew" linear correction, which uses a 4x4 linear homogenous
transform on the translation part.  This works a bit better than just a 3x3
rotation/scaling on the translation.  By ignoring the rotation, and
trans<->rot cross coupling, this gets around the problem of rotation
wrapping.  Wrapping was giving really crappy results with the axis sweep,
especially wrt DNL.  "skew" gives almost as low error on the large grid data
as the "pose" 6x6 transform, while avoiding the wrapping problem.

It would seem that the linear correction was not reducing fixture error,
eg. Rz runout, since we get similar performance without any rotation effect.
rot->trans coupling is clearly a big error, but the 'pose' transform was not
getting at it.

I added the linear correction into the calibrate_main.m script so we can
generate this as part of the main calibration.  This automation makes the
procedure less error-prone.

So the state of the art calibration is dipole + skew correction (for
premo/rotated dipole):
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 11
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
               stage_coords: 1
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/XYZ_hr_cal_skew_corrected.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880
Optimizing fixture poses: both
source_fix_delta =
  -0.00037509  -0.00014137    0.0002766    0.0018123  -0.00064503   0.00040122
sensor_fix_delta =
  -9.3819e-05   2.0201e-05  -0.00012474   0.00081512   0.00022785   -6.472e-05
Position error (m): 2.40e-04 RMS, 5.63e-04 max.
Orientation error (radians): 5.99e-03 RMS, 1.12e-02 max
trans_err_rms =
   0.00015116   0.00013647   0.00012755
rot_err_rms =
    0.0026149    0.0033791    0.0041965
________________________________________________________________


It seems I have kind of exhausted what I can do using the current calibration
and data (single source fixturing) with the rotated corner dipole/Premo.  The
only open question is how well it will generalize to gross source motion,
which needs new data.

When we have source fixture indexing, then this will presumably improve
generalization across source motion, and might make source quadrupole useful
(although likely only with the cmu-concentric source).


Went back and looked at cal_5_19_premo_cmu, using the CMU concentric source,
and source quadrupole.  I regenerated all the calibrations, now using pinned
quadrupole. 
________________________________________________________________
               d_source_pos                          d_source_moment                             d_sensor_pos                              d_sensor_moment           
    ___________________________________    ____________________________________    _________________________________________    _____________________________________
    -0.016913    0.0029223            0     0.78935     0.0025428             0     9.8087e-05     4.2811e-05              0      0.40062    0.00064663             0
      0.00248    -0.017196            0           0       0.90597             0     3.6633e-05     8.3223e-05              0            0       0.39853             0
     0.018626     0.014787            0    0.022976    -0.0020089             1    -0.00010553    -0.00015115              0    0.0058085     0.0049504       0.40872
    q_source_pos             q_source_moment             q_sensor_pos    q_sensor_moment
    ____________    _________________________________    ____________    _______________
    0    0    0     -4.8456      0.35752     -0.20183    0    0    0       0    0    0  
    0    0    0     0.27964      -3.7958    -0.045437    0    0    0       0    0    0  
    0    0    0      1.2478      0.41796      -2.6342    0    0    0       0    0    0  
Source fix: [0.27871 0.01351 0.02583 0.02887 0.05146 -1.61237 ]
Sensor fix: [-0.00020 0.00029 -0.00015 -2.20162 -2.23040 -0.00041 ]

cal_residue =
     0.011002

>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
          linear_correction: 0
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
               stage_coords: 1
                    issweep: 0
                   cal_file: 'so_quadrupole_all_hr_cal'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
10 invalid points with residual > 1e-05.
bad_points =
        1316        1318        1347        1348        1357        1367        1372        1377        1382        1387
Position error (m): 3.87e-04 RMS, 1.28e-03 max.
Orientation error (radians): 1.64e+00 RMS, 6.28e+00 max
trans_err_rms =
   0.00012682   0.00020335   0.00030396
rot_err_rms =
       1.1609     0.044005        1.152
________________________________________________________________

With skew correction:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
               stage_coords: 1
                    issweep: 0
                   cal_file: 'so_quadrupole_all_hr_cal_skew_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
10 invalid points with residual > 1e-05.
bad_points =
        1316        1318        1347        1348        1357        1367        1372        1377        1382        1387
Position error (m): 3.34e-04 RMS, 9.27e-04 max.
Orientation error (radians): 1.64e+00 RMS, 6.28e+00 max
trans_err_rms =
   0.00011998   0.00019092   0.00024668
rot_err_rms =
       1.1609     0.044005        1.152
________________________________________________________________


Dipole only:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
               stage_coords: 1
                    issweep: 0
                   cal_file: 'XYZ_hr_cal'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
12 invalid points with residual > 1e-05.
bad_points =
        1270        1271        1276        1291        1296        1311        1316        1348        1352        1353        1357        1377
Position error (m): 4.48e-04 RMS, 1.34e-03 max.
Orientation error (radians): 5.72e-03 RMS, 1.29e-02 max
trans_err_rms =
   0.00013467   0.00030436   0.00029955
rot_err_rms =
    0.0030535    0.0036072     0.003219
________________________________________________________________

Dipole + skew:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
               stage_coords: 1
                    issweep: 0
                   cal_file: 'XYZ_hr_cal_skew_corrected'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
12 invalid points with residual > 1e-05.
bad_points =
        1270        1271        1276        1291        1296        1311        1316        1348        1352        1353        1357        1377
Position error (m): 3.84e-04 RMS, 9.60e-04 max.
Orientation error (radians): 5.72e-03 RMS, 1.29e-02 max
trans_err_rms =
   0.00012347   0.00023877   0.00027485
rot_err_rms =
    0.0030535    0.0036072     0.003219
________________________________________________________________


Comparing [21 May 21], it seems the non-pinned quadrupole is better than the
pinned, but pinned quadrupole + skew is almost as good.  We would expect the
calibration with more DOF to give lower error in the test setup, but it might
not generalize as well.

None of these calibrations with cmu-concentric is as good as the rotated
corner dipole + premo, especially for max error.  The difference is fairly
big, which makes the cmu-concentric source somewhat unpromising.  Might work
better with the current sheet approximation.




[2 Jun 21]

Summary, with rotated corner dipole/Premo:
 -- With the quadrupole position pinned to the dipole, the sensor quadrupole
    is giving a fairly sane result, and showing an accuracy improvement.
 -- The sensor quadrupole is showing some screwy behavior related to a shift
    in the fixture transform.
 -- The sensor quadrupole + linear correction is not really any better than
    dipole + linear.  There is also an odd huge trans->rot coupling in the
    linear correction.
 -- With pinned quadrupole, the source quadrupole is calibrated to near
    zero, and has no effect on the accuracy.
 -- Weighting the linear correction by the moment didn't do anything.  It
    gives the same transform.


Sort of interesting sensor quadrupole run with rotated corner dipole/premo.
________________________________________________________________
>> calibrate_main
C:\Users\robma\Documents\Work\ilemt\cal_data\5_25_premo_rotated_dipole
            cal_mode: 'se_quadrupole_all'
              sensor: 'premo'
    base_calibration: 'se_quadrupole_hr_cal'
              ishigh: 1
              debias: 0
                bias: [3×3 double]
           normalize: 1
        sensor_signs: [1 1 -1]
        source_signs: [1 1 -1]
         in_fixtures: {'Z_rot'  'X_rot'  'Y_rot'}
           data_size: 'md'
            optimize: {'q_se_pos'  'q_se_mo'  'd_so_pos'  'd_so_mo'  'd_se_pos'  'd_se_mo'  'so_fix'  'se_fix'}
              freeze: {'d_so_y_co'  'd_se_y_co'}
            out_file: 'se_quadrupole_all_hr_cal'
            in_files: {'Z_rot_md.dat'  'X_rot_md.dat'  'Y_rot_md.dat'}
                 d_source_pos                            d_source_moment                            d_sensor_pos                              d_sensor_moment           
    _______________________________________    ___________________________________    _________________________________________    _____________________________________
     0.045025    -0.00072988              0      0.94432    0.0061231            0     0.00017682     0.00011183              0      0.15788    0.00030241             0
    0.0016205       0.045653              0            0      0.94582            0     2.6205e-05     1.3994e-05              0            0       0.15718             0
    -0.043884      -0.042583              0    -0.033798    0.0069698            1    -0.00012741    -0.00010236              0    0.0022671      0.001897       0.16101
    q_source_pos    q_source_moment                 q_sensor_pos                            q_sensor_moment           
    ____________    _______________    ______________________________________    _____________________________________
    0    0    0       0    0    0       -0.028766      0.011392       0.05791    -0.023762      -0.00402    0.00095357
    0    0    0       0    0    0        0.031772     -0.020869      0.037881    -0.011466     -0.022037     -0.036999
    0    0    0       0    0    0      -0.0075513     -0.025817      0.033854     0.013922     0.0078035     0.0036576
Source fix: [0.13313 0.11862 0.09599 0.75102 -0.31814 -0.78447 ]
Sensor fix: [-0.00014 0.00018 -0.00021 -2.20211 -2.22961 -0.00021 ]

[...]
                 d_source_pos                            d_source_moment                            d_sensor_pos                              d_sensor_moment           
    _______________________________________    ___________________________________    _________________________________________    _____________________________________
     0.044938    -0.00077906              0       0.9449    0.0055771            0     -0.0038014    -0.00039067              0      0.15783    0.00027108             0
    0.0016455       0.045612              0            0      0.94596            0    -0.00087837     -0.0054135              0            0       0.15709             0
    -0.043902      -0.042573              0    -0.034054    0.0070507            1     0.00032862     0.00073946              0    0.0022133     0.0019429       0.16089
    q_source_pos    q_source_moment                  q_sensor_pos                            q_sensor_moment          
    ____________    _______________    _________________________________________    __________________________________
    0    0    0       0    0    0       -0.0029058     0.00011366       0.061485     -1.3034    -0.089855    0.0010098
    0    0    0       0    0    0      -5.4313e-05     -0.0033488       0.037521    -0.14749      -1.7201    -0.036318
    0    0    0       0    0    0        0.0018008    -0.00020152       0.036887    0.061559      0.12455    0.0061634
Source fix: [0.13307 0.11866 0.09592 0.75067 -0.31737 -0.78419 ]
Sensor fix: [-0.00010 0.00017 -0.00019 -2.20208 -2.22987 -0.00029 ]

cal_residue =
     0.014534

>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/se_quadrupole_all_hr_cal.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880

source_fix_delta =
  -0.00033671  -0.00015443   0.00031811     0.001266  -0.00065808   0.00070895
sensor_fix_delta =
   -8.402e-05  -4.7108e-07    -9.87e-05   0.00076063   0.00027296  -0.00059731
Position error (m): 3.12e-04 RMS, 9.31e-04 max.
Orientation error (radians): 5.59e-03 RMS, 1.06e-02 max
trans_err_rms =
   0.00018257   0.00016787   0.00018956
rot_err_rms =
    0.0023176    0.0031818    0.0039714
________________________________________________________________

Note that the XY quadrupole position ran away during the 'se_quadrupole'
optimization, but came back during 'se_quadrupole_all', to where it is nearly
cooincident with the dipole.  XY moments are also roughly similar.  So the XY
results seem physically plausible.  Not sure what is happening with the Z.
This is similar to what we have seen in the past with the source quadrupole,
where I thought it might be due to the lack of source fixturings making this
non-identifiable.  But with the sensor fixturings I would expect that similar
info is available for all the coils.  Possibly once the Z position ran away
there was not enough evidence to drag it back.

The accuracy improvement is a fairly modest 10% or so compared to
XYZ_hr_cal_corrected.mat, but the max position error is worse.

With linear correction:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/se_quadrupole_all_hr_cal_corrected.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880

source_fix_delta =
  -0.00035699  -0.00016543   0.00030564    0.0012335  -0.00081088    0.0011606
sensor_fix_delta =
  -7.5493e-05   3.9661e-05  -0.00014073   7.6074e-05   0.00061316  -0.00066308
Position error (m): 2.33e-04 RMS, 7.12e-04 max.
Orientation error (radians): 4.25e-03 RMS, 1.04e-02 max
trans_err_rms =
   0.00015176   0.00013129   0.00011927
rot_err_rms =
    0.0016256    0.0023424    0.0031492
________________________________________________________________

This is pretty similar to what we got with the dipole+linear, so it seems that
the quadrupole and linear are getting at similar errors, rather than being
synergistic.  Once again, the translation max error is worse.


Here's the sensor quadrupole with the quadrupole position pinned to the dipole:
________________________________________________________________
>> calibrate_main
C:\Users\robma\Documents\Work\ilemt\cal_data\5_25_premo_rotated_dipole
            cal_mode: 'se_quadrupole_all'
              sensor: 'premo'
    base_calibration: 'base_calibration'
              ishigh: 1
              debias: 0
                bias: [3×3 double]
           normalize: 1
      pin_quadrupole: 1
        sensor_signs: [1 1 -1]
        source_signs: [1 1 -1]
         in_fixtures: {'Z_rot'  'X_rot'  'Y_rot'}
           data_size: 'md'
            optimize: {'q_se_mo'  'd_so_pos'  'd_so_mo'  'd_se_pos'  'd_se_mo'  'so_fix'  'se_fix'}
              freeze: {'d_so_y_co'  'd_se_y_co'}
            out_file: 'se_quadrupole_all_hr_cal'
            in_files: {'Z_rot_md.dat'  'X_rot_md.dat'  'Y_rot_md.dat'}
                 d_source_pos                            d_source_moment                            d_sensor_pos                              d_sensor_moment           
    _______________________________________    ___________________________________    _________________________________________    _____________________________________
     0.044938    -0.00077906              0       0.9449    0.0055771            0     -0.0038014    -0.00039067              0      0.15783    0.00027108             0
    0.0016455       0.045612              0            0      0.94596            0    -0.00087837     -0.0054135              0            0       0.15709             0
    -0.043902      -0.042573              0    -0.034054    0.0070507            1     0.00032862     0.00073946              0    0.0022133     0.0019429       0.16089
    q_source_pos    q_source_moment    q_sensor_pos             q_sensor_moment          
    ____________    _______________    ____________    __________________________________
    0    0    0       0    0    0      0    0    0      -1.3034    -0.089855    0.0010098
    0    0    0       0    0    0      0    0    0     -0.14749      -1.7201    -0.036318
    0    0    0       0    0    0      0    0    0     0.061559      0.12455    0.0061634
Source fix: [0.13307 0.11866 0.09592 0.75067 -0.31737 -0.78419 ]
Sensor fix: [-0.00010 0.00017 -0.00019 -2.20208 -2.22987 -0.00029 ]

[...]

                 d_source_pos                           d_source_moment                            d_sensor_pos                             d_sensor_moment           
    _______________________________________    __________________________________    ________________________________________    _____________________________________
     0.044985    -0.00073362              0     0.94482     0.005785            0    -0.0038465    -0.00020868              0      0.15778    0.00025226             0
     0.001603       0.045599              0           0      0.94641            0    -0.0010106     -0.0034661              0            0       0.15706             0
    -0.043902      -0.042608              0    -0.03362    0.0070593            1     0.0045685      0.0030737              0    0.0024578     0.0020104       0.16075
    q_source_pos    q_source_moment    q_sensor_pos              q_sensor_moment          
    ____________    _______________    ____________    ___________________________________
    0    0    0       0    0    0      0    0    0       -1.0362     0.069341     -0.11864
    0    0    0       0    0    0      0    0    0     -0.065465     -0.91514    -0.094683
    0    0    0       0    0    0      0    0    0       0.10483      -0.1308       1.2494
Source fix: [0.13310 0.11860 0.09594 0.75075 -0.31798 -0.78442 ]
Sensor fix: [0.00054 0.00098 0.00379 -2.20184 -2.22949 -0.00192 ]

cal_residue =
     0.014968


>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/se_quadrupole_all_hr_cal.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1319        1399        1473

source_fix_delta =
  -0.00032976   -0.0001362   0.00030485    0.0013078   -0.0006708   0.00079041
sensor_fix_delta =
  -8.4964e-05   2.3127e-05  -8.1795e-05   0.00044595   0.00045184  -0.00080392
Position error (m): 2.92e-04 RMS, 8.59e-04 max.
Orientation error (radians): 5.69e-03 RMS, 1.05e-02 max
trans_err_rms =
   0.00017236   0.00015943    0.0001738
rot_err_rms =
     0.002306    0.0035246    0.0038331

________________________________________________________________

The cal_residue is almost as low as with the free quadrupole position, and the
errors are slightly better.  There is a big change in the quadrupole moments,
especially Z, which now has a similar magnitude to XY, although the sign is
flipped for some reason.  Could this have to do with the sign flip in the
hardware Z connection?  IDK

There are also pretty significant movements in the sensor dipole positions and
sensor fixture, at the mm level.  Among other things, this results in a
significant point spread with Rz in the error vector plot.  This is odd, but
is maybe not actual error?  We have used the Z dipole as the origin, and (due
to the fixture change) this has moved relative to the physical sensor
position.  It is not entirely pleasing that the dipole has moved away from the
physical center.  Presumably it has been dragged by the quadrupole, which
seems not to want to be in the exact same place.

There is in some sense a risk that by discarding the fixture transforms in the
calibration, we are causing an error in the result.  But this error is
constrained to resemble a rigid transform of the source and sensor, so is
pretty benign.  And if we did have a definite notion of where the source and
sensor origin should be, then we could force that by adjusting the Z dipoles.

 ==> Hmmn, we also have relatively huge values in transform(1:3, 4:6), the
     translation->rotation coupling.

The correction sort of "works", but this is not encouraging.  I suspect this
has to do with the Rz loop now expected in the XY position.  Once again,
perhaps not "wrong", IDK.

Overall, I am not a fan of what we are seeing with the sensor quadrupole.  We
seem to get similar benefit from dipole only + linear, and the calibration
seem less screwy.  But the real test would be how well it generalizes,
especially to different source fixturings.


Source quadrupole with rotated corner dipole/Premo:
________________________________________________________________
>> calibrate_main
C:\Users\robma\Documents\Work\ilemt\cal_data\5_25_premo_rotated_dipole
            cal_mode: 'so_quadrupole_all'
              sensor: 'premo'
    base_calibration: 'so_quadrupole_hr_cal'
              ishigh: 1
              debias: 0
                bias: [3×3 double]
           normalize: 1
      pin_quadrupole: 1
        sensor_signs: [1 1 -1]
        source_signs: [1 1 -1]
         in_fixtures: {'Z_rot'  'X_rot'  'Y_rot'}
           data_size: 'md'
            optimize: {'q_so_mo'  'd_so_pos'  'd_so_mo'  'd_se_pos'  'd_se_mo'  'so_fix'  'se_fix'}
              freeze: {'d_so_y_co'  'd_se_y_co'}
            out_file: 'so_quadrupole_all_hr_cal'
            in_files: {'Z_rot_md.dat'  'X_rot_md.dat'  'Y_rot_md.dat'}
                 d_source_pos                            d_source_moment                            d_sensor_pos                             d_sensor_moment           
    _______________________________________    ___________________________________    _________________________________________    ____________________________________
     0.045087    -0.00068058              0      0.94432    0.0061287            0     0.00017682     0.00011183              0     0.15788    0.00034119             0
    0.0016744       0.045702              0            0      0.94582            0     2.6205e-05     1.3994e-05              0           0       0.15715             0
    -0.043684      -0.042384              0    -0.033806    0.0069613            1    -0.00012741    -0.00010236              0    0.002356     0.0019369       0.16103
    q_source_pos                 q_source_moment                 q_sensor_pos    q_sensor_moment
    ____________    _________________________________________    ____________    _______________
    0    0    0      0.00013838     -0.0011867     -0.0074662    0    0    0       0    0    0  
    0    0    0     -4.8212e-05     -0.0020077      -0.006613    0    0    0       0    0    0  
    0    0    0     -0.00017767     -0.0002672      -0.053206    0    0    0       0    0    0  
Source fix: [0.13320 0.11867 0.09619 0.75100 -0.31813 -0.78447 ]
Sensor fix: [-0.00009 0.00022 -0.00015 -2.20217 -2.22923 -0.00112 ]

[...]

                 d_source_pos                            d_source_moment                            d_sensor_pos                             d_sensor_moment           
    _______________________________________    ___________________________________    _________________________________________    ____________________________________
     0.045086    -0.00068174              0      0.94432    0.0061285            0      0.0001771     0.00011189              0     0.15788    0.00034129             0
    0.0016732       0.045701              0            0      0.94582            0       2.62e-05     1.3729e-05              0           0       0.15715             0
    -0.043693      -0.042391              0    -0.033807    0.0069609            1    -0.00012705    -0.00010205              0    0.002356      0.001937       0.16103
    q_source_pos                 q_source_moment                 q_sensor_pos    q_sensor_moment
    ____________    _________________________________________    ____________    _______________
    0    0    0      9.0908e-07     -0.0011844     -0.0073468    0    0    0       0    0    0  
    0    0    0      -3.375e-05     -0.0020037     -0.0065127    0    0    0       0    0    0  
    0    0    0     -0.00012048    -0.00026768      -0.051239    0    0    0       0    0    0  
Source fix: [0.13320 0.11867 0.09618 0.75100 -0.31813 -0.78447 ]
Sensor fix: [-0.00009 0.00022 -0.00014 -2.20217 -2.22923 -0.00112 ]

cal_residue =
     0.016409

>>  check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/so_quadrupole_all_hr_cal.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880

source_fix_delta =
  -0.00034396  -0.00015267   0.00031235    0.0012019  -0.00059812   0.00071892
sensor_fix_delta =
  -9.3624e-05   2.0106e-05  -0.00012401   0.00068828    0.0005479  -0.00062172
Position error (m): 3.11e-04 RMS, 8.48e-04 max.
Orientation error (radians): 6.05e-03 RMS, 1.13e-02 max
trans_err_rms =
   0.00018225   0.00016822   0.00018731
rot_err_rms =
    0.0027136    0.0033977    0.0042082
________________________________________________________________

The source quadrupole is miniscule with pinned position compared to what we
were seeing before, but I had suspected that whatever was going on was not
well identified.  I checked, and this is identical to what I am now getting
with dipole-only:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 0
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/XYZ_hr_cal.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880

source_fix_delta =
   -0.0003435  -0.00015261   0.00031181    0.0011981  -0.00059479   0.00071839
sensor_fix_delta =
  -9.3643e-05   2.0104e-05  -0.00012406   0.00068538   0.00054827  -0.00062116
Position error (m): 3.11e-04 RMS, 8.47e-04 max.
Orientation error (radians): 6.05e-03 RMS, 1.13e-02 max
trans_err_rms =
   0.00018207   0.00016822    0.0001871
rot_err_rms =
    0.0027135    0.0033993    0.0042086
________________________________________________________________

This dipole-only number is a bit lower than what I got yesterday with only
source fixture optimization in check_poses.  So it seems that, at least with
the location pinned, the source quadrupole is negligible with the rotated
corner dipole.


I tried adding scaling by the moment to the linear correction, but it didn't
do anything.

Doing a translation-only linear correction seems to work nearly as well, and
avoids glitching due to angle wrapping.  But it still under-corrects the XYZ
scale in the axis sweep.
 ==> Maybe there are not enough internal points in the medium data, and errors
     at the corners are causing compromise.  Try large data for linear correction?
 ==> Nope, very little difference on large data (even though same as test data)


[1 Jun 21]

The linear correction also works well with the large data:
    cal_data\cal_5_28_premo_rotated_dipole 

This was taken after the Rz realignment, and possible motion of the source,
and benefits from doing fixture optimization in check_poses.

________________________________________________________________

>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'both'
                     moment: 0.05
          linear_correction: 1
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 1
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/XYZ_hr_cal_corrected.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880

source_fix_delta =
  -0.00037591  -0.00015243   0.00026686    0.0014697  -0.00059853    0.0013182
sensor_fix_delta =
  -0.00010268   4.4312e-05  -0.00013689   4.2806e-05   0.00035485  -0.00034827
Position error (m): 2.30e-04 RMS, 5.70e-04 max.
Orientation error (radians): 5.03e-03 RMS, 9.67e-03 max
trans_err_rms =
   0.00014865   0.00012885   0.00011858
rot_err_rms =
    0.0020426    0.0029539      0.00352
________________________________________________________________


Compare to without the linear correction:
________________________________________________________________
>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 'source'
                     moment: 0.05
          linear_correction: 0
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 1
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: '../5_25_premo_rotated_dipole/XYZ_hr_cal_corrected.mat'
               sensor_signs: [1 1 1]
               source_signs: [1 1 1]
                   in_files: {'Z_rot_ld.dat'  'X_rot_ld.dat'  'Y_rot_ld.dat'}
5 invalid points with residual > 1e-05.
bad_points =
        1293        1295        1348        1850        1880
source_fix_delta =
  -0.00033741  -0.00011043   0.00034062    0.0014245  -0.00075376   0.00073599
sensor_fix_delta =
     0     0     0     0     0     0
Position error (m): 3.46e-04 RMS, 9.03e-04 max.
Orientation error (radians): 6.10e-03 RMS, 1.15e-02 max
trans_err_rms =
   0.00021863   0.00019825   0.00018108
rot_err_rms =
    0.0030901    0.0033521    0.0040504
________________________________________________________________

For translation, error is reduced 33% RMS and 47% max.  For rotation, 18% and
12%.

re. interpretation of the linear correction, from previous entry.

The rotation->translation terms are in the range 5..50 um, which is the same
order of magnitude as probable fixturing error.  So it is hard to be confident
that this is correcting actual measurment error.  Looking at the
perr_axis_response plot is not reassuring, since there is a strong sinusoidal
component.  But the oscillation seems to peak about every 90 degrees, which is
4x what we would expect from simple Rz runout.  I don't know what kinematic
factor could cause this periodicity.
 ==> are these plots over-smoothed?
 ==> Reducing the sg_filt_F from 17 to 9 gives much noisier derivatives, but
     has pretty minimal effect on the INL.  This however does not help the
     weird behavior of the off-axis derivatives.



Maybe the off-axis derivative effect comes from taking the vector magnitude of
the off-axis terms?  This certainly is forcing the DNL to be positive.  Also,
I'm comparing a vector magnitude (INL) to a vector magnitude of DNL.  This is
not going to give a derivative relationship between the two.  For example, if
the error is a straight line in 3-space, the DNL is fixed, but the line is
going to have a closest approach to the true value, giving an INL with a bend.
 ==> Still possible the off-axis DNL has a bug

There is some puzzling jumps at the beginning and end of the off-axis DNL,
especially in the Z response.  This looks sort of like a data start/end
effect.

The smoothness of the DNL is heavily determined by the window width, and the
max DNL is moderately affected.  To be conservative it seems we should opt for
rather less smoothing.  Also, using more closely spaced points in the pattern
will give a lower noise derivative.  Given the current pattern resolution,
F=17 seems rather too much.

Perhaps we should say that the off-axis DNL is inscrutable/irrelevant?  We do
care about the on-axis DNL, because this is our local error, and the INL
because it is overall error.  For off-axis, we care about the total off-axis
error, but perhaps not so much about the DNL?  I guess we do want to know
about the off-axis error due to a small move, though.  We don't particularly
care about the curve, but knowing the general magnitude (or max) is useful.

But for all that matter, the user isn't going to care about the wiggles in the
INL curve either.  I want to look at these mainly to provide insight into the
error process, but they are also useful in publication to illustrate the INL
vs. DNL concept, and to show that the DNL computation is meaningful.  Probably
skip the off-axis plots for publication.


We can understand the higher-order periodicity in the Rz response as harmonic
distortion, which will always appear when a nonlinear system is excited with a
periodic signal.  The magnetics are definitely nonlinear, so it is easy to
imagine that they might cause fourth-harmonic content.  A quadrupole has four
peaks when rotated, but they have alternating signs, so could perhaps create
only second harmonic content.

Note that our rotation is of the sensor, so we would expect to be seeing
mainly dipole deviations of the sensor response.


One thought, re. linear correction, is that even if it only works over the
calibrated workspace, that workspace is still aready a lot larger than ASAP.
In particular, for doing correlation with ASAP under free motion, we don't
really need to work with large source rotations.  So I could start work in
that direction, such as with the rabbit experiments.  And it is not completely
unrealistic to use the linear correction, even if it is rather ad-hoc.


[28 May 21]

Not sure what to make of this, but a pinv() linear correction of the measured
pose seems pretty effective.  Most obviously, this corrects for an apparent
gain error in the translation, but the full 6x6 transform is correcting for
who-knows-what, and likely overfitting.

eg. with 5_25_premo_rotated_dipole I am getting:
________________________________________________________________
>> perr_report_overall(perr)
Position error (m): 2.56e-04 RMS, 5.50e-04 max.
Orientation error (radians): 4.27e-03 RMS, 1.01e-02 max
trans_err_rms =
   0.00015933   0.00016602   0.00011279
rot_err_rms =
    0.0017815    0.0032055    0.0021876
________________________________________________________________

with the correction, rather than:
________________________________________________________________
Position error (m): 3.51e-04 RMS, 8.40e-04 max.
Orientation error (radians): 5.55e-03 RMS, 1.18e-02 max
trans_err_rms =
   0.00019952   0.00020968   0.00019844
rot_err_rms =
    0.0028205    0.0036717    0.0030639
________________________________________________________________

This is with the exact same data used for calibration, though, nevermind the
same source fixturing.  With the 6x6 transform we are adding 36 DOF to the
calibration, which certainly increases the risk of overfitting.

This is the transform matrix:
________________________________________________________________
       1.0014   0.00049187   -0.0017722   -0.0041402    0.0060831   -0.0031132
   0.00033711       1.0014  -0.00096297   -0.0043652   -0.0060402     0.011438
   -0.0025403   -0.0025033       1.0033     0.015057   -0.0047506     0.003578
  -8.9773e-06  -4.7035e-05   1.2361e-05       1.0003   -0.0012278    0.0017259
   4.5162e-06   2.6504e-05  -2.9201e-05   -0.0010068       1.0007   0.00011469
   2.0523e-05   2.9992e-05   -4.301e-06    0.0011922    0.0014333      0.99893
________________________________________________________________

We have some scale factor errors around 1e-3.  The off-diagonal
translation->translation or rotation->rotation transforms can I guess be
kinematically interpreted as axis non-orthogonality.  The interpretation of
the translation<->rotation cross couplings is somewhat more inscrutable.  But
these terms are also kind of smallish, eg. 1 rad Rz movement causing 30 um Y
translation.

I guess the rot->trans terms, transform(4:6, 1:3), are interpreted as a moment
in meters.  And the trans->rot transform(1:3, 4:6) are what?  A curvature I
guess.  meters/radian is a moment, ie. a radius, so radians/meter is 1/radius,
or a curvature.

If this correction is useful, then we should weight it for rotation
vs. translation, eg. using our moment.  With 50mm moment, 1 mrad error causes
50 um moment error, whereas 1mm causes 1mm.  So translation error should be
weighted higher than rotation.

FWIW, using the linear correction (from medium XYZ data) on the axis sweep
does improve things, although the X and Y gain errors are rather
under-corrected.  There a glitch in the Rz sweep response which may be due to
angle-wrapping.  Maybe it would be better to estimate the error, rather than
the corrected pose?  This would avoid large angles in the result.  But
estimate the error as a transform, rather than difference of pose vectors?
eg. find transform that maps measured to desired, and convert to pose vector,
then pinv() that.  Or something.

A physical interpretation for effectiveness of the linear correction is also
elusive.  It could absorb ground truth errors, magnetic interference, or other
magnetic model shortcomings.  It is of course unsurprising that we can reduce
the residue by adding more DOF to the model, the big question is whether it
has any generality.

The pose is wrt. the source coordinates, though, so if the error we are
capturing is in the source, then the correction could work when the source is
refixtured.


[27 May 21]

I got data with the Premo sensor and the corner dipole source with the
rotated fixture (for all-positive poses).

It looks like the Premo Z axis really is sign-swapped?  In the lab I convinced
myself that the coupling signs are +++ in this setup, as are the input signs.
So that is how I took this data, but it didn't work in Matlab until I flipped
both the source and sensor signs for Z.  The source flip was needed because of
the + coupling sign I used in ilemt_ui.

________________________________________________________________
>> calibrate_main
C:\Users\robma\Documents\Work\ilemt\cal_data\5_25_premo_rotated_dipole
            cal_mode: 'XYZ'
              sensor: 'premo'
    base_calibration: 'Z_only_hr_cal'
              ishigh: 1
              debias: 0
                bias: [3×3 double]
           normalize: 1
        sensor_signs: [1 1 -1]
        source_signs: [1 1 -1]
         in_fixtures: {'Z_rot'  'X_rot'  'Y_rot'}
           data_size: 'md'
            optimize: {'d_so_pos'  'd_so_mo'  'd_se_pos'  'd_se_mo'  'so_fix'  'se_fix'}
              freeze: {'d_so_y_co'  'd_se_y_co'}
            out_file: 'XYZ_hr_cal'
            in_files: {'Z_rot_md.dat'  'X_rot_md.dat'  'Y_rot_md.dat'}

                 d_source_pos                            d_source_moment                            d_sensor_pos                             d_sensor_moment           
    _______________________________________    ___________________________________    _________________________________________    ____________________________________
     0.045025    -0.00072988              0      0.94432    0.0061231            0     0.00017682     0.00011183              0     0.15788    0.00034119             0
    0.0016205       0.045653              0            0      0.94582            0     2.6205e-05     1.3994e-05              0           0       0.15715             0
    -0.043884      -0.042583              0    -0.033798    0.0069698            1    -0.00012741    -0.00010236              0    0.002356     0.0019369       0.16103
Source fix: [0.13313 0.11862 0.09599 0.75102 -0.31814 -0.78447 ]
Sensor fix: [-0.00009 0.00022 -0.00015 -2.20217 -2.22923 -0.00112 ]

cal_residue =
     0.016437

>> check_poses
                     ishigh: 1
            valid_threshold: 1e-05
                do_optimize: 0
                     moment: 0.05
                axis_limits: [6×2 double]
                  sg_filt_N: 2
                  sg_filt_F: 17
    onax_ignore_Rz_coupling: 1
             xyz_exaggerate: 10
                    issweep: 0
                   cal_file: 'XYZ_hr_cal.mat'
               sensor_signs: [1 1 -1]
               source_signs: [1 1 -1]
                   in_files: {'Z_rot_md.dat'  'X_rot_md.dat'  'Y_rot_md.dat'}
Not doing optimization.
Position error (m): 3.51e-04 RMS, 8.40e-04 max.
Orientation error (radians): 5.55e-03 RMS, 1.18e-02 max
trans_err_rms =
   0.00019952   0.00020968   0.00019844
rot_err_rms =
    0.0028205    0.0036717    0.0030639
________________________________________________________________

So, this does look more accurate.  With small data on [12 May 21] I got:
    Position error (m): 5.65e-04 RMS, 1.45e-03 max.
    Orientation error (radians): 7.40e-03 RMS, 1.92e-02 max

I think this is the best dipole-only calibration so far.  Aside from the
source fixture and the non-flipped Z sensor, this is pretty much the same
calibration as I got with the non-rotated corner dipole in
cal_data\cal_5_12_premo on [12 May 21].

The pose solution was frequently diverging, until I changed it so the pose
solution initial state is the stage null pose (based on the fixture
transforms). 




[21 May 21]


Took a look at check_poses() on:
    cal_data\cal_5_19_dipole_cmu\Z_rot_ld_source_move.dat

where there is a big motion and rotation of the source.  Results are
disappointing, but not appalling.

First, there is a problem with the pose solution convergence.  Even after
adjusting for the negative X present by constraining to the +Y hemisphere,
there are 106 points that failed to converge.  A better initial state might
help, or trying several initial states.  The previous pose convergence
problems went away when I improved the sensor cross coupling.  So having a
poor fitting model definitely aggravates the situation.  Possibly this is
contributed to by not having derivatives in the optimization.

I tried running a Z-only calibration to find the source fixture, and that did
not work.  It seems that calibration can't deal with the source fixture being
way wrong.
________________________________________________________________
>> check_poses
data_file =
    'Z_rot_ld_source_move.dat'
cal_file =
    '../cal_5_13_dipole_cmu/XYZ_hr_cal.mat'
106 invalid points with residual > 4e-06.
source_fix_delta =
     -0.38889      0.19339      0.16549      0.30783      0.86827       2.1602
sensor_fix_delta =
     0     0     0     0     0     0
Position error (m): 9.21e-04 RMS, 2.83e-03 max.
Orientation error (radians): 8.66e-03 RMS, 3.06e-02 max
trans_err_rms =
   0.00048533   0.00047631    0.0006214
rot_err_rms =
    0.0054891    0.0049997    0.0044658
________________________________________________________________

So, error is increased a bit more than 2x.

The pose solution completely failed when I tried the corresponding quadrupole
calibration: 
    cal_5_13_dipole_cmu/so_quadrupole_all_hr_cal.mat

This is consistent with my thinking that the source quadrupole calibration is
being hugely warped by not seeeing the source from enough different
directions.

My feel is that results would be much improved if we had multiple source
fixturings in the calibration, and I have been developing a concept for that.
The Rx rotator we built for the source is just not going to be accurate enough
unless we locate and interface an encoder with much higher resolution.  And we
also just don't need continuous rotation.

Before we can publish calibration results we need:
 1] A reliable pose solution
 2] Measurement that is robust across a much wider pose space.

So the source fixturing is a pretty high priority.  Fixing the calibration may
fix the solution, but also we can do something like initialize the pose using
the closed-form solution (even though it isn't fully general for our
calibration model).


I got the source fixtures for the dipole-source variations, with the rotated
cube, and also the in-line configuration.  Possibly a dipole-only calibration
with these would generalize better to more varied source fixtures, since the
dipole conformance is already much better than the concentric cube, and may be
further improved when cross-coupling effects are reduced.

It's discourging for replication that we are needing so much calibration data
with our specialized stage setup.  But it is still plausible that once we have
a calibration that it will work fairly well across duplicate coils, especially
with the non-concentric dipole, where manufacturing is less demanding.  The
dipole-only calibration also does not seem to need a whole lot of data, and
even for quadrupole or other higher order models, likely we will decide that
there are degrees of freedom we don't need (perhaps force the quadrupole to
the same position as the dipole).

So there are two somewhat divergent directions for calibration/accuracy work:
 1] Get real good accuracy
 2] Get a source/sensor setup that can be replicated

Either way, we first need to get accuracy which is not embarrassing.  Using
the Premo source (and sensor) is an easy path to [2].  There is some value in
using diverse sources and sensors, in that it shows the flexibility of ILEMT
(and really of magnetic trackers in general).

I would say max error < 1mm and RMS error < 400 um is "not embarrassing",
which is where we are with the single source fixture, but this needs to be
reached over a large workspace, ideally any chosen source hemisphere.  We need
this for at least one source/sensor configuration, ideally with several.


If we are going to incorporate multiple source fixturings in the calibration,
then we need another transform in the kinematic chain, and more fitted
parameters.  It may work to have the new transform fully specified, and then
to let existing parameters move, like the Z position and moment.  We could
have a nominal translation from fixture origin to source origin (just to give
a pleasing source origin), and then fold in the fixtured rotations.  Having
three axis rotations in the fixture creates a definite origin for the fixture.

So, for one, there is a terminological problem.  The way that we fixture the
source seems like it ought to be called the source fixture.

Currently we have:
    source_fixture -> stage_pose (with sensor fixturings) -> sensor_fixture

What source fixture is currently doing is absorbing the difference between the
source and stage coordinates.  This includes both the source-sensor offset and
the (delibrate and incidental) misalignment of the source with the stage.


Working on the calibration using the Premo sensor and CMU-concentric source.
Previously, did only a Z-only calibration.
________________________________________________________________
>> calibrate_main
cal_mode = 'XYZ'
sensor = 'premo'
base_calibration = 'Z_only_hr_cal'
base_calibration = '../cal_5_12_premo_cmu/Z_only_hr_cal.mat'

C:\Users\robma\Documents\Work\ilemt\cal_data\cal_5_19_premo_cmu
                  d_source_pos                             d_source_moment                             d_sensor_pos                              d_sensor_moment           
    ________________________________________    _____________________________________    _________________________________________    _____________________________________
    -0.0028945    -0.00011047              0      0.82607     0.0015808             0    -0.00012876    -0.00031151              0      0.39349    0.00086347             0
    0.00015078     -0.0012705              0            0      -0.90029             0     5.7612e-05      6.366e-05              0            0       0.39122             0
     0.0012655      0.0012935              0    0.0013535    0.00057268             1    -4.2505e-05     2.2434e-05              0    0.0056013     0.0048971      -0.40279
Source fix: [0.23508 0.02007 0.01656 0.00500 0.02437 -1.57890 ]
Sensor fix: [-0.00017 0.00059 -0.00011 -2.20387 -2.22663 0.00019 ]
...
                  d_source_pos                              d_source_moment                              d_sensor_pos                              d_sensor_moment           
    ________________________________________    _______________________________________    _________________________________________    _____________________________________
    -0.0014751     0.00030267              0      0.81115     -0.0053118              0     9.2837e-05     2.7821e-05              0      0.39883    0.00064818             0
    0.00065909    -0.00089752              0            0        0.89452              0     3.8776e-05     7.8837e-05              0            0       0.39674             0
     0.0013461        0.00145              0    0.0017676    -0.00050934              1    -8.2363e-05    -0.00012719              0    0.0058004     0.0049038      -0.40686
Source fix: [0.27606 0.01515 0.01564 0.02786 0.05267 -1.60501 ]
Sensor fix: [-0.00019 0.00030 -0.00014 -2.20160 -2.23035 -0.00046 ]

cal_residue = 0.011961

>> check_poses
data_file =
  1×3 cell array
    {'Z_rot_ld.dat'}    {'X_rot_ld.dat'}    {'Y_rot_ld.dat'}
cal_file =
    'XYZ_hr_cal.mat'
2 invalid points with residual > 4e-06.
bad_points =
        1295        1468
Not doing optimization.
Position error (m): 4.48e-04 RMS, 1.34e-03 max.
Orientation error (radians): 5.73e-03 RMS, 1.29e-02 max
trans_err_rms =
   0.00013429   0.00030547   0.00029948
rot_err_rms =
    0.0030533    0.0036122    0.0032267
________________________________________________________________

The dipole-only calibration accuracy is in a similar ballpark to what we have
been getting with other source/sensor combinations.  eg. the
CMU-concentric/corner-dipole dipole-only on [14 May 21].  It's plausible that
with the concentric source the dipole-nonconformity is dominating the error. 


Quadrupole calibration:
________________________________________________________________

                d_source_pos                            d_source_moment                              d_sensor_pos                              d_sensor_moment           
    _____________________________________    ______________________________________    _________________________________________    _____________________________________
    -0.064188    -0.0002677             0       0.79892     0.0041624             0     9.7385e-05     4.3394e-05              0      0.39582    0.00063899             0
    0.0032811    -0.0001245             0             0       0.90534             0     3.8252e-05     8.5439e-05              0            0       0.39376             0
     0.018486      0.001386             0    -0.0090211     0.0019202             1    -0.00010655    -0.00015121              0    0.0057394     0.0048852      -0.40382
               q_source_pos                           q_source_moment               q_sensor_pos    q_sensor_moment
    ___________________________________    _____________________________________    ____________    _______________
    -0.030663     0.025625      0.66946    -13.253    -0.00032061       0.083697    0    0    0       0    0    0  
    0.0014523      0.17662    -0.022666    0.31501        -0.1394      -0.010338    0    0    0       0    0    0  
    0.0046965    -0.024916     0.030904     1.3144       -0.14808      -0.098797    0    0    0       0    0    0  

Source fix: [0.27556 0.01376 0.01569 0.02834 0.05229 -1.60982 ]
Sensor fix: [-0.00020 0.00029 -0.00015 -2.20162 -2.23039 -0.00038 ]

Optimization stopped because the norm of the current step, 8.964558e-07,
is less than options.StepTolerance = 1.000000e-06.

cal_residue =
     0.010702
>> check_poses
data_file =
  1×3 cell array
    {'Z_rot_ld.dat'}    {'X_rot_ld.dat'}    {'Y_rot_ld.dat'}
cal_file =
    'so_quadrupole_all_hr_cal.mat'
1 invalid points with residual > 4e-06.
bad_points =
        1443
Not doing optimization.
Position error (m): 3.16e-04 RMS, 7.44e-04 max.
Orientation error (radians): 1.43e+00 RMS, 6.28e+00 max
trans_err_rms =
   0.00011849   0.00021248   0.00020218
rot_err_rms =
       1.0138     0.037315       1.0051
________________________________________________________________

This seems to be a nice low error (although the rotation is messed up due to
wrapping).  But the calibration is not physically credible.  YZ are not doing
much at all, and are in random positions.  X is doing something, but
both the dipole and quadrupole positions have wandered to a rather silly
degree (64mm) in -X.  This is much the lowest error we have gotten so far,
which is nice, but I don't expect it to generalize to any significantly
different source orientation.


[19 May 21]

 ==> In axis sweep, off-axis and cross DNL look screwy.  They aren't the
     derivative of the displayed INL.  The on-axis results are sensible.
 ==> Mess with the SG filter params, maybe too much smoothing?

Got a higher res axis sweep with current calibration, cal_5_19_dipole_cmu.
Looking at this, it seems the position error is quite linear, basically scale
error, with off-axis error that could be interpreted as axis misalignment.
Thinking of trying a pseudo-inverse correction.  While this is unlikely to
generalize to significantly different source orientations, would be
interesting to see what it can do.
 ==> If linear transform on pose is effective, this suggests an error taking
     place in Euclidian space, i.e. not a magnetic effect, possibly a ground
     truth error.

 ==> The errors we are seeing are not way higher than plausible stage error,
     maybe 3x to 5x?  Not 10x.  This is worrying.  eg. I said stage XY
     orthogonality is 0.6 mrad, whereas off-axis translation due to X is about
     1.2 mrad.


 ==> Thought about how reducing residue might not reduce "error".  I've been
     paying most attention to position error, so possibly a change that
     reduces orientation error at the cost of position might go unnoticed.
     But IIRC, in the screwed cases both trans and rot got worse.


Looked again, using new error_scatter() function, and in cal_5_13_dipole_cmu
there is a definite trend for position error to increase at the lower coupling
magnitudes.  Interestingly, the rotation error sort of decreases (reduces in
variance) at the lower couplings.

The effect is less pronounced when we plot vs. the sensor distance (from
nominal source origin).  Note that this is with the concentric CMU cube
source, so the source-sensor distance is fairly well-defined.  This suggests
that the larger errors may arise in situations where the coupling is
unfavorable due to relative orientation.

The rotation effect is rather more surprising, but I guess comes from better
dipole approximation.  Our calibration normalization by the coupling magnitude
might also contribute, since we weight the more distant poses higher, which in
some sense degrades the accuracy of the closer poses.


[25 May 21]

Looking at the corner dipole source with the angle bracket for the
all-positive workspace.
At pose:
        -5	0	25	0	0	-1	

I am getting a pleasingly symmetrical coupling with Premo sensor:
	0.032	0.055	-0.042	
	-0.033	0.055	0.037	
	-0.081	0.000	-0.080	

With rotated-dipole/Premo it looks like the coupling signs are +++.  And (as
before) there are no input inversions with Premo.

It seems that with the rotated dipole source the source axis sum (used in the
ilemt_ui distance calculation) varies noticeably less with motion in the
sensor X and Z directions (which are nominally tangential to the source).

 ==> Digital indicator pressure moves the column approx 60 um radially.  This
     is not good for the Z axis alignment procedure.  The stiffness seems
     to be roughly the same in all Rz positions, but this doesn't really
     help.  The Rz center is going to appear 60 um offset in the stage Y
     direction. 


[14 May 21]

Summary:
 -- Got a pretty good calibration result with CMU-concentric cube source and
    corner-dipole sensor, using source quadrupole.  344 um RMS translation,
    1090 um max.
 -- The cube source seems to have significantly higher quadrupole, resulting
    in more benefit and less silly fit results.
 -- The sensor fixture transform and sensor dipole positions (for corner
    dipole) are quite similar between this data and
    cal_data/cal_11_5/XYZ_hr_cal, despite being taken on different days.
 -- When we are looking at error differences of 10's of percent, and
    quadrupole calibration, we need to be running comparisons with the same data
    size: medium three-fixture calibration and large three-fixture test.


Seems perhaps we are not primarily limited by source or sensor cross coupling
currently?  Because our tested accuracy is roughly similar between the various
concentric and non-concentric sources and sensors.

Something I did notice is that there seems to be less rotation-translation
coupling in the error vectors with the CMU-concentric/corner-dipole setup:
they splay out less across the rotations.  I would think that translation
error due to sensor rotation would mainly be due to sensor effects, but this
is the same sensor that we started out with, the only thing nominally
different is the source.

It also does seem that with recent data, eg. using the CMU-concentric source,
that the tendency for errors to be specifically associated with -Z and -Y is
reduced, so that error more generally increases away from the workspace center
in all directions.

There is the general pattern of U-shaped error as you move away from the
center.  While broadly, a tendency for error to get worse away from the center
is somewhat reasonable, this would be more the case as you go outside of the
calibrated region.  An insufficient model could cause this sort of thing; the
optimization is doing its best to minimize the error by splitting the
difference. 


I need to more consistently compare the different configurations, using the
same calibration and test data input types, eg. calibrate with medium, test
with large, or whatever.

Also, it is possible there is non-reproducibility in our procedure.  Worth
taking some data that is supposed to be the same, and seeing if the results
differ, and perhaps directly compare the data.


"funny things" to follow up on:
 -- Is premo sensor with CMU concentric source really much better than with
    corner-dipole source?  Then why, with corner-dipole source is it much
    worse than corner-dipole sensor with that source?  And premo /
    CMU-concentric is not better?
 -- Why does Premo sensor quadrupole calibration make error so much worse? Big
    difference between optimizing residue vs. pose error.


I'd like to look at the coupling error vs. the pose error in poses with bad
pose error.  I guess, more generally, can scatter coupling error vs. pose
error.


I'd kind of been thinking that the calibration fit was getting worse as I
added the three rotations, but the residual is not normalized by the number
calibration points, and is expected to increase linearly.  Getting a residual
of 6e-3 with three-angle medium data is entirely in line with a residual of
1e-3 for single-angle small data.  We are getting a bit lower in that case,
but not a lot lower, something like 0.85e-3.

If we take the per-point squared residual, and take the sqrt(), then the
per-point RMS residual is something like 4e-3.


Calibration and test with CMU concentric/corner-dipole
________________________________________________________________

>> calibrate_main

cal_mode = 'so_quadrupole_all'
sensor = 'dipole'
base_calibration = 'so_quadrupole_hr_cal'

optimize =
    {'q_so_pos'}    {'q_so_mo'}    {'d_so_pos'}    {'d_so_mo'}    {'d_se_pos'}    {'d_se_mo'}    {'so_fix'}    {'se_fix'}

D:\ilemt\cal_data\cal_5_13_dipole_cmu

                 d_source_pos                            d_source_moment                             d_sensor_pos                             d_sensor_moment            
    ______________________________________    _____________________________________    ________________________________________    ______________________________________

    -0.0015945     0.0002228             0    0.75286       0.024297              0      0.013822    -0.00039809              0       0.45147    -0.0072535             0
    0.00048023     -0.001007             0          0        0.89164              0    0.00020174       0.013526              0             0       0.44989             0
     0.0013637     0.0013192             0    0.03679    -0.00037367              1     -0.013897      -0.013594              0    -0.0078329     0.0029856       0.44925

                  q_source_pos                             q_source_moment              q_sensor_pos    q_sensor_moment
    _________________________________________    ___________________________________    ____________    _______________

      -0.086413       0.089725       0.024497    -3.7817      0.016741      0.046714    0    0    0       0    0    0  
       0.014707      -0.076931       0.050617     1.0026     -0.021661    -0.0018915    0    0    0       0    0    0  
    -0.00042169       0.015891       -0.03218     1.2733    0.00091775       0.12646    0    0    0       0    0    0  

Source fix: [0.27578 0.00975 0.01608 0.02747 0.04873 -1.62545 ]
Sensor fix: [0.00008 0.00002 0.01369 0.00861 -0.00708 1.55802 ]

[...]

                 d_source_pos                             d_source_moment                              d_sensor_pos                             d_sensor_moment            
    ______________________________________    _______________________________________    ________________________________________    ______________________________________

    -0.0057893      0.003941             0      0.75418     -0.0014229              0      0.013809    -0.00038436              0        0.4613    -0.0074053             0
     0.0014537     -0.003928             0            0        0.88095              0    0.00019665       0.013505              0             0       0.45973             0
     0.0091378     0.0040576             0    0.0011875    -0.00039658              1     -0.013853      -0.013554              0    -0.0079653     0.0031078       0.45913

                 q_source_pos                         q_source_moment             q_sensor_pos    q_sensor_moment
    ______________________________________    ________________________________    ____________    _______________

      -0.01904          0.02      0.031624     -3.0917     0.16369     0.17474    0    0    0       0    0    0  
    5.8061e-05     -0.039867      0.004036    0.067844    -0.57296    0.021343    0    0    0       0    0    0  
    -0.0013582     0.0093377     -0.015955     0.47724    0.001119     0.64964    0    0    0       0    0    0  

Source fix: [0.27964 0.01760 0.01840 0.02454 0.05009 -1.59651 ]
Sensor fix: [0.00008 0.00001 0.01366 0.00855 -0.00704 1.55804 ]

cal_residue = 0.010199

>> check_poses

data_file =
    {'Z_rot_md.dat'}    {'X_rot_md.dat'}    {'Y_rot_md.dat'}

cal_file =
    'so_quadrupole_all_hr_cal.mat'

source_fix_delta =
   2.2173e-05  -2.3391e-05   2.3427e-05  -0.00027248   2.3054e-05   0.00038264

sensor_fix_delta =
  -1.3913e-05  -2.8525e-05   8.0935e-06   0.00079409   3.4519e-05  -0.00029946

Position error (m): 3.89e-04 RMS, 1.14e-03 max.
Orientation error (radians): 4.51e-03 RMS, 8.06e-03 max

trans_err_rms =
   0.00014895   0.00021533   0.00028725

rot_err_rms =
    0.0035583    0.0022521    0.0016126

% Same, but with large data
>> check_poses

data_file =
    {'Z_rot_ld.dat'}    {'X_rot_ld.dat'}    {'Y_rot_ld.dat'}

cal_file =
    'so_quadrupole_all_hr_cal.mat'

source_fix_delta =
  -2.2122e-05  -8.5111e-05   6.5347e-05    0.0010534   0.00088409   0.00048733

sensor_fix_delta =
  -2.4131e-05   3.7302e-06  -1.4635e-05   0.00057019  -2.8876e-05   -0.0012298

Position error (m): 3.44e-04 RMS, 1.09e-03 max.
Orientation error (radians): 3.67e-03 RMS, 6.69e-03 max

trans_err_rms =
   0.00013137   0.00018341   0.00025958

rot_err_rms =
    0.0025425     0.002018    0.0017047
________________________________________________________________


This is a reasonable result; it sort of meets my goal of <400um RMS <1mm max.
We are pretty solidly below 400um RMS.  Note that testing with the large data
actually helped both RMS and max.  The RMS kind of makes sense because we add
more interior points which have lower error.  So it does not seem to hurt to
test with the large three-fixture data, which is good.  And testing with
Z-only data is also worse, I think because error seems somewhat concentrated
in that fixturing.

This is with the source quadrupole calibration, which this time has behaved
rather more sensibly with this source/sensor and cal data.  The error vectors
seem more balanced across the workspace, and the quadrupole seems more
physically plausible, with smallish position offsets and somewhat diagonal
moments.  With my cube coil it is fairly plausible that there is off-center
stuff, because it is hand wound with incomplete layers on an asymmetrical
core.  It is even plausible that the pattern varies across the axes, because
of the layering.  But my suspicion is that there are still big problems with
observability of the YZ quadrupole.

This is what we get with the dipole-only calibration:
________________________________________________________________

>> check_poses
data_file =
    {'Z_rot_ld.dat'}    {'X_rot_ld.dat'}    {'Y_rot_ld.dat'}

cal_file =
    'XYZ_hr_cal.mat'

source_fix_delta =
  -1.1261e-05   -6.851e-05   0.00010669    0.0011229   0.00097337    0.0012774

sensor_fix_delta =
  -1.6821e-05  -2.0314e-05  -2.5248e-05   0.00061534  -0.00046382   -0.0013291

Position error (m): 4.48e-04 RMS, 1.35e-03 max.
Orientation error (radians): 4.54e-03 RMS, 1.18e-02 max

trans_err_rms =
   0.00015124   0.00027042    0.0003237

rot_err_rms =
    0.0030417    0.0023825    0.0023823


>> print_calibration(cal)
                 d_source_pos                             d_source_moment                               d_sensor_pos                             d_sensor_moment            
    ______________________________________    ________________________________________    ________________________________________    ______________________________________

    -0.0015945     0.0002228             0       0.79611     -0.0034907              0      0.013822    -0.00039809              0       0.45147    -0.0072535             0
    0.00048023     -0.001007             0             0        0.88548              0    0.00020174       0.013526              0             0       0.44989             0
     0.0013637     0.0013192             0    0.00042184    -0.00067026              1     -0.013897      -0.013594              0    -0.0078329     0.0029856       0.44925

Source fix: [0.27474 0.01807 0.01581 0.02561 0.04943 -1.59268 ]
Sensor fix: [0.00008 0.00002 0.01369 0.00861 -0.00708 1.55802 ]
________________________________________________________________


With this configuration we are getting a fairly significant 23% reduction in
RMS translation and 19% max from the quadrupole.  It seems that the dipole
error of this source may be better approximated by a quadrupole than is the
case for the corner-dipole source.  This supported by the X quadrupole
magnitude from cal_5_11/all_hr_cal being about 5x smaller.

Comparing the quadrupole to dipole-only calibration, what is different?  The
dipole source positions have moved quite a bit off-center.  And the dipole
moment decreased.  Also, the sensor gain has increased about 2% (surely
actually a source referred effect).

The d_sensor_pos and sensor fixture really have not changed.  The source
fixture X has moved 5mm, but this is probably related to the mm motions of the
dipole positions.  Because we are forcing the Z dipole to zero position, if
the Z dipole has moved (eg. due to the Z quadrupole) then it will drag the
source fixture pose.  Likewise, when the Z quadrupole adds to the Z dipole
(unit moment) then this changes the gain, and so the d_sensor_moment.  It's
not great that the origin is moving off the presumed mechanical center of the
source, but if we really care about that, then we should mechanically center
the calibration, such as by adding source rotations.

Note that the quadrupole that we got from optimizing only the source
quadrupole (position and moment) and the source dipole (moment only) really do
not agree very well at all with what we ended up with after the full
optimization.  I'll add the source dipole positions to the initial quadrupole
optimization.

FWIW, comparing this calibration to cal_data/cal_5_11/XYZ_hr_cal, the sensor
dipole positions and sensor fixture are very similar, within 10's of um and a
mrad or so.  This is encouraging about the repeatability of the sensor
fixturing.  (The sensor moment magnitude is quite different because the CMU
concentric source seems about 2x stronger, but the off-axis is kind of
similar, though one sign flip.)


[13 May 21]

Summary:
 -- CMU concentric cube coil is working fairly well.
 -- Cube source axis orthogonality is much better (20x) than the corner-dipole
    source.
 -- Failure of coupling bias estimation strongly suggests other error sources
    are dominant (though reducing cal residue has not always improved pose
    error).
 -- If current error is due to magnetic interference, then the real issue is
    what would happen in a more realistic environment.  But we are probably
    not seeing much magnetic interference, based on the radial motion due to
    interferers.
 -- Trying sensor quadrupole with small three fixture data on Premo sensor did
    not end well, which is not surprising.  But odd how terrible the error was
    when tested on the same data as used for cal.  Minimizing coupling residue
    clearly does not always minimize pose error.
 -- A bit of testing of the sensitivity of pose solution to coupling
    perturbations.  It seems to be in the ballpark of delta*r, though
    usually 2-3x better.  Ideas for systematic sensitivity test.
 

The CMU concentric coil seems to work pretty well, based on Rz only
calibration and testing.

With cal_5_12_premo_cmu, the CMU coil and Premo sensor, I get:
________________________________________________________________

>> calibrate_main

cal_mode = 'Z_only'
sensor = 'premo'
in_files = 'Z_rot_sd.dat'

freeze =    {'d_so_y_co'}    {'d_se_y_co'}    {'z_se_fix'}

C:\Users\robma\Documents\Work\ilemt\cal_data\cal_5_12_premo_cmu

                  d_source_pos                             d_source_moment                             d_sensor_pos                              d_sensor_moment           
    ________________________________________    _____________________________________    _________________________________________    _____________________________________

    -0.0028945    -0.00011047              0      0.82607     0.0015808             0    -0.00012876    -0.00031151              0      0.39349    0.00086347             0
    0.00015078     -0.0012705              0            0      -0.90029             0     5.7612e-05      6.366e-05              0            0       0.39122             0
     0.0012655      0.0012935              0    0.0013535    0.00057268             1    -4.2505e-05     2.2434e-05              0    0.0056013     0.0048971      -0.40279

Source fix: [0.23508 0.02007 0.01656 0.00500 0.02437 -1.57890 ]
Sensor fix: [-0.00017 0.00059 -0.00011 -2.20387 -2.22663 0.00019 ]

>> check_poses

data_file = 'Z_rot_md.dat'
cal_file = 'Z_only_hr_cal.mat'

Not doing optimization.
Position error (m): 3.94e-04 RMS, 8.14e-04 max.
Orientation error (radians): 1.05e+00 RMS, 6.28e+00 max

trans_err_rms =
   0.00014352    0.0002828    0.0002331

rot_err_rms =
      0.74538      0.74462     0.008243
________________________________________________________________

This is a better than the best corner-dipole/dipole results, especially on max
error, and RMS is quite significantly better that corner-dipole/premo.  For
some reason the check_poses fixture optimization flaked out, perhaps related
to the sensor fixture rotation being near pi?

Source axis orthogonality is ~20x better than the corner-dipole source, which
is probably related to less cross-coupling.  As I think I noted before, the
off-axis compensation converges much faster with the CMU-concentric source
than with the corner-dipole.  The concentricity according to the d_source_pos
(~2mm) is also pretty good, considering the core is made from glued E-cores
(with holes) rather than an actual cube, and is also hand-wound.

The Y source moment being flipped seems to be a Premo sensor interaction,
because it doesn't happen with the CMU-concentric/corner-dipole.


What to do next?
 -- it seems likely that the combo of CMU-concentric source with the dipole
    sensor will give the best accuracy yet.  So we want a good amount of data
    in that setup. 
 -- worth trying whether the sensor quadrupole helps the Premo sensor, and how
    much the source quadrupole helps the CMU-concentric.  To look at
    quadrupole, we want the XYZ data, preferably medium size. 
 -- Revisit coupling bias correction, look at pose sensitivity to coupling.


What are we trying to achieve here?
 -- Low error, over full pose space (not currently tested)
 -- Insight into error mechanisms.  What is the effectiveness of the dipole
    coil?  When is cross-coupling a problem?
 -- A practical near-term source/sensor configuration
 -- Everything else: a usable real-time system, publications and documentation

Considering "everything else", one of our criteria is when to stop trying to
improve accuracy.  But it does make sense to concentrate on one thing at a
time.

Research needs feed back into experiments, but at least initially I can
concentrate on getting the best accuracy.  For maybe 2 weeks?  One research
test that could feed back into accuracy work is the coupling sensitivity.


General comments on calibration/test data:
 -- At least for dipole calibration, there is not a whole lot of difference in
    accuracy with medium vs. small data, and with three fixtures vs. one.
 -- Error is worse with three fixtures (which makes sense), and IIRC
    calibrating with three fixtures helps the three fixture test results
    (which also makes sense).
 ==> [13 May 21] Not clear this is true, cal residual is larger because more points.
 -- Three fixture medium data does seem to make the source quadrupole term
    more observable.


It tentatively seems that the quadrupole is more beneficial for the cube
coils, at least so far as calibration residual goes. (Which is what we would
expect.)  But the results are still physically unreasonable for axis asymmetry
and quadrupole location, and this is likely due to under-constraint /
insufficient data.  Might be worth a try to constrain the quadrupole to the
same location as the dipole.  This would regularize the solution into a form
that is more likely to generalize to other source configurations.  A distant
location for the quadrupole could also suggest magnetic interference.


Other interpretation:
 -- That the bias estimate from mean residue did not help kind of proves that
    other errors are dominant, probably way dominant.  Because it *would* have
    worked if bias had been dominant.
 -- If magnetic interference is what we are seeing in the test setup, then it
    would be rather hopeless to get better accuracy in any realistic setting.
    But my feel from the 1DOF measurement errors I've seen is that even if we
    multiply 10x to get 3DOF position error, its going to be less than 200um,
    and 100um or less seems likely.


I tried sensor quadrupole with the corner-dipole/premo, and it reduced the
residue a fair amount, but made error about 2x worse, tested on the exact same
calibration data.
________________________________________________________________
>> calibrate_main

cal_mode = 'se_quadrupole_all'
sensor = 'premo'
base_calibration = 'se_quadrupole_hr_cal'

optimize =
    {'q_se_pos'}    {'q_se_mo'}    {'d_so_pos'}    {'d_so_mo'}    {'d_se_pos'}    {'d_se_mo'}    {'so_fix'}
    {'se_fix'}

C:\Users\robma\Documents\Work\ilemt\cal_data\cal_5_12_premo

                 d_source_pos                            d_source_moment                            d_sensor_pos                               d_sensor_moment            
    _______________________________________    ___________________________________    _________________________________________    _______________________________________

     0.046059    -0.00097317              0      0.93065    0.0027972            0     0.00034788     0.00015744              0      0.15873    -3.1629e-05              0
    0.0023127       0.046151              0            0       0.9465            0    -0.00022111    -3.9673e-05              0            0        0.15817              0
    -0.044711      -0.042794              0    -0.025737     0.011003            1    -0.00049703    -0.00034355              0    0.0025223      0.0015475       -0.16168

    q_source_pos    q_source_moment                q_sensor_pos                            q_sensor_moment            
    ____________    _______________    _____________________________________    ______________________________________

    0    0    0       0    0    0      -0.042981      0.030592    -0.0062105     -0.019118      -0.17397      0.066714
    0    0    0       0    0    0      -0.015958     -0.035286     -0.014011    -0.0086062     -0.091542      -0.02458
    0    0    0       0    0    0      -0.011211      0.083887      0.022254       0.03386      0.063594      -0.28419

Source fix: [0.24990 0.02790 -0.03741 0.01394 0.01790 -1.56198 ]
Sensor fix: [-0.00002 0.00007 -0.00059 -2.20160 -2.23248 -0.00116 ]


>> check_poses

data_file =
    {'Z_rot_sd.dat'}    {'X_rot_sd.dat'}    {'Y_rot_sd.dat'}

cal_file =
    'se_quadrupole_all_hr_cal.mat'

Not doing optimization.
Position error (m): 6.59e-04 RMS, 2.25e-03 max.
Orientation error (radians): 7.99e-03 RMS, 3.47e-02 max

trans_err_rms =
   0.00017457   0.00041487   0.00048074

rot_err_rms =
    0.0038418    0.0048087    0.0050908

>> sum(sum(sum(norm_residue.^2)))

ans =

    0.0024784
________________________________________________________________

It bears some thought how we can be reducing the residue yet increasing the
position error when run on the training data.  Of course if we were
overfitting then we *would* expect this, but only when run on *other* data.

So it seems that to a *significant* degree, under some conditions, minimizing
the residue is not resulting in reduced pose error.  That is, the goal we are
giving optimization is not really correct.  We've considered this general
possibility, and this is the reason for the normalization in the objective
function, but...

The thing is, the pose solution is minimizing the exact same residue, but on
only a single point.  So when we optimize the calibration ensemble, we must
not be correctly weighting the points.
 ==> One idea is that we could emperically weight the data, based on observed
     errors.  This could capture e.g. error increase at the edges of the
     workspace.
 ==> Normalizing by the norm of the coupling is not aggressive enough to
     minimize error across range variation, since (I assume, like noise) error
     goes as r^4, while field strength as 1/r^3.

 ==> Given a certain level of model error, it's a somewhat arbitrary decision
     which points to give high error, and which low.  Traditionally you try to
     equalize, which tends to minimize max error, while also working OK on
     RMS.  But given the intrinsic tendency of error to increase with range,
     perhaps it makes more sense to just allow that?

What sort of error specification you consider acceptable comes in here.
Trying to force the error to act unnaturally may increase the risk of
overfitting to the particular test data.  But this only actually applies if we
were weighting the pose error, which we are not.


Thoughts on sensitivity:

Some exploratory probes suggest that the sensitivity is about what you would
expect, or perhaps 2-3x less.  eg. a 1% scaling causes less than 1% distance
error.  In the home pose (r = 250mm), 1% scaling or 10 mrad rotation cause
about 1mm error.  For the radial translation error, we expect below linear,
since the radial distance is a cube root.  1.01^(1/3) = 1.0033

A rotation of the coupling roughly corresponds to a rotation of the measured
field, such as is caused by magnetic interference or model error.  For a
concentric symmetric sensor this is a pretty close correspondence.


To look at this systematically:
 -- Test across the workspace
 -- Try several different perturbations, eg. scaling or rotation of row or
    column of coupling
 -- Look at radial and tangential position, angular, and moment.  Summary
    statistics across these.


A somewhat different thing to consider is sensitivity to perturbations in the
calibration.

And another question is: what is the sensitivity to fixture pose error?  I
guess rotation of the sensor is similar to rotation of the coupling matrix, so
sensitivity should be similar.  And if there is stage runout, then that
directly contributes to translation error.


[12 May 21]

Summary:
 -- Concerns about fixturing accuracy and Rz runout
 -- Dipole and quadrupole calibrations with the dipole-approximating source
    and sensor.  Quadrupole helps a bit.
 -- Thoughts on how to check for input sign flips or wrong coupling signs.
 -- Premo sensor is now working ok, but error is rather worse than with the
    corner dipole sensor (Z-only test data).

I reworked forward_kinematics.m, without changing what it computes.  It is
clearer now, and also significantly faster.  I am now pretty sure it is doing
what I think it should be doing.  I have not gone over fk_coupling, the dipole
part, but that has gotten a lot of attention in the past, and seems to be
working (based on the fairly good dipole model fit).


Got new data for the dipole and premo sensors.  I re-zeroed the Rz XY offset
on the stage before taking the dipole data.  It was not too far out, something
like 100 um.  But this is not very stable, and the instability is probably
partly in alignment of the calibration fixture.  I am not at all confident in
the fixturing at the 100um level.

The premo data is not cooperating, must be inconsistent kinematics or initial
state is too far off.  But coupling at zero pose looks weird, big Y value is
not on the diagonal.


The dipole data is "medium" size, and is working, without the X sign flip (now
cancelled in ilemt_ui).

cal_data/cal_5_11/XYZ_hr_cal, residual 6.4e-3
________________________________________________________________

                 d_source_pos                            d_source_moment                            d_sensor_pos                             d_sensor_moment            
    _______________________________________    ___________________________________    ________________________________________    ______________________________________

     0.046059    -0.00096892              0       0.9116    0.0023166            0      0.013832    -0.00037614              0       0.18034    -0.0028503             0
    0.0023164       0.046113              0            0       0.9356            0    0.00018629       0.013539              0             0       0.17968             0
    -0.044225      -0.042902              0    -0.033719      0.01138            1     -0.013867      -0.013598              0    -0.0029648     0.0012663       0.17953

Source fix: [0.24994 0.02792 -0.03705 0.01345 0.01752 -1.56213 ]
Sensor fix: [0.00009 0.00003 0.01366 0.00751 -0.00652 1.55689 ]

>> check_poses

data_file = 'Z_rot_ld.dat'
cal_file = 'XYZ_hr_cal.mat'

source_fix_delta =
  -4.2209e-05  -9.0034e-05  -7.7893e-05   0.00088732   -0.0011039    0.0023495

sensor_fix_delta =
  -6.9268e-05   0.00012095   0.00044659    0.0026587   0.00032639    -0.003711

Position error (m): 4.59e-04 RMS, 1.55e-03 max.
Orientation error (radians): 4.06e-03 RMS, 1.21e-02 max

trans_err_rms =
   0.00017733    0.0002855   0.00031333

rot_err_rms =
    0.0015718    0.0020301    0.0031463
________________________________________________________________

Using the medium data for calibration does not seem to have improved the
performance on the Rz only test data.  It is somewhat worse, though that may
be meaningless.  And no sign that my fiddling with accurate fixturing made a
difference either (which likely means other errors dominate).  The increase in
calibration residual is expected because there is about 2x more data.


cal_5_11/all_hr_cal, residual 5.9e-3
________________________________________________________________

               d_source_pos                             d_source_moment                              d_sensor_pos                            d_sensor_moment          
    _____________________________________    _______________________________________    ________________________________________    ___________________________________

     0.045131    -0.0021892             0      0.90181    -0.00058719              0      0.013826    -0.00036938              0      0.18068    -0.002861            0
    0.0022953      0.045289             0            0        0.94315              0    0.00018607       0.013525              0            0      0.18003            0
    -0.043106     -0.042973             0    -0.032261       0.012017              1      -0.01384      -0.013568              0    -0.002962    0.0012792      0.17989

                 q_source_pos                           q_source_moment               q_sensor_pos    q_sensor_moment
    ______________________________________    ____________________________________    ____________    _______________

      0.030633      0.038236      0.052042    -0.61268    -0.0047262    -0.0046114    0    0    0       0    0    0  
    -0.0065335     0.0082803      0.031533    -0.10651      -0.12423     -0.020706    0    0    0       0    0    0  
      -0.05575      -0.04118      -0.11768     0.13535     0.0050364     0.0077363    0    0    0       0    0    0  

Source fix: [0.25015 0.02862 -0.03684 0.01467 0.01668 -1.55913 ]
Sensor fix: [0.00009 0.00003 0.01364 0.00753 -0.00654 1.55686 ]


>> check_poses

data_file = 'Z_rot_ld.dat'
cal_file = 'all_hr_cal.mat'

source_fix_delta =
  -7.3387e-05  -0.00012045  -8.7217e-05   0.00068599  -0.00047161    0.0015142

sensor_fix_delta =
  -7.4012e-05    0.0001552   0.00043344    0.0026771   0.00014869   -0.0030038

Position error (m): 4.36e-04 RMS, 1.44e-03 max.
Orientation error (radians): 3.75e-03 RMS, 1.20e-02 max

trans_err_rms =
   0.00016714    0.0002468    0.0003184

rot_err_rms =
    0.0012487    0.0019432    0.0029527

________________________________________________________________

So, with source quadrupole, with medium data, we are seeing about the same as
with the small data, but somewhat worse RMS error.  BTW, having the
'quadrupole' mode optimize 'd_so_mo', but not 'd_so_pos', or any sensor
parameters, worked quite well for getting started.  I had to add a hack to
calibrate_main to initialize the source quadrupole to non-zero due to the
zero/near-zero feature in forward_kinematics now actually working.

The XY quadrupole parameters are somewhat similar to what we got on [4 May 21]
using cal_5_3 small data, but Z is completely different.  XY also hold to the
pattern that moment is roughly diagonal, opposite in sign to the dipole, and
somewhat nearish to the dipole location.  I can't see any explanation for why
the axes would be so dissimilar except for the very asymmetric test data.
Only on X do we see both sides of the axis, and so are able to see whether the
field is axisymmetric or not.  Probably the dropping moments across YZ are due
to less support from the data.  In this run, there is really nothing from the
Z quadrupole.  Not only is the moment small, the position has run away to a
silly degree.


Is there a testing procedure for identifying the coupling signs and sensor
sign flips?  It's hard to get this right, especially when there is any
possible confusion about the sensor fixture.

 -- First, make sure the axis assignment is right, which (if the source axis
    assigment is right) we can do by checking for the strong couplings on the
    diagonal.

We need to drive the strong coupling off the diagonal to disambiguate

If flips and signs are correct, then:
 -- If you align each sensor axis the same way wrt. a single source axis, then
    the signs will all be the same, eg. + for aligned out the source axis.
 -- If you repeat this on the other source axes, then the signs will all be +
    also. 


I got the Premo sensor working, though there is a sign flip on the Z moment.
________________________________________________________________
>> calibrate_main

cal_mode = 'XYZ'
sensor = 'premo'
base_calibration = 'Z_only_hr_cal'

D:\ilemt\cal_data\cal_5_12_premo

                d_source_pos                          d_source_moment                            d_sensor_pos                              d_sensor_moment           
    _____________________________________    __________________________________    _________________________________________    _____________________________________

     0.045963    -0.0011718             0     0.93181    0.0015271            0     0.00018147     0.00015695              0      0.15856    0.00011797             0
    0.0024399       0.04613             0           0      0.94817            0     6.7801e-05     0.00011691              0            0        0.1579             0
    -0.044607     -0.042704             0    -0.02722     0.011294            1    -0.00013145     -2.515e-05              0    0.0020626     0.0017512      -0.16185

Source fix: [0.24982 0.02828 -0.03736 0.01360 0.01848 -1.56050 ]
Sensor fix: [-0.00023 0.00014 -0.00011 -2.20229 -2.23307 0.00189 ]

>> check_poses

data_file = {'Z_rot_sd.dat'}    {'X_rot_sd.dat'}    {'Y_rot_sd.dat'}
cal_file = 'XYZ_hr_cal.mat'

source_fix_delta =
   9.1768e-05  -5.0925e-05   0.00013758   -0.0013059   -0.0013746    0.0017815

sensor_fix_delta =
  -7.4656e-05  -0.00012261   4.0865e-05   -0.0012663    0.0031979    -0.001031

Position error (m): 5.65e-04 RMS, 1.45e-03 max.
Orientation error (radians): 7.40e-03 RMS, 1.92e-02 max

trans_err_rms =
   0.00019547   0.00034563   0.00040232

rot_err_rms =
    0.0039798    0.0042419    0.0045678

>> check_poses
data_file = 'Z_rot_sd.dat'
cal_file = 'XYZ_hr_cal.mat'

source_fix_delta =
   1.7233e-05  -3.3147e-05    0.0001601  -0.00072513  -0.00082492    0.0027424

sensor_fix_delta =
   3.9896e-05   1.9547e-05   6.1865e-05   -0.0031723    0.0051423   0.00031039

Position error (m): 5.11e-04 RMS, 1.23e-03 max.
Orientation error (radians): 7.07e-03 RMS, 1.87e-02 max

trans_err_rms =
    0.0001923   0.00029532    0.0003704

rot_err_rms =
    0.0024773    0.0044266    0.0049271
________________________________________________________________

Error is somewhat worse RMS than what we are getting with the dipole sensor, but
the sensor calibration is extremely "pretty": good symmetry, orthogonality and
alignment.
 ==> This suggests that source error may dominate. Possibly worse dipole
     conformance is having an effect, need to try quadrupole.  *sensor*
     quadrupole? 

But that it does work is basically good news because it means we can get
reasonable results with a commerical sensor.



[11 May 21]

Summary:
 -- Phase calibration and sign issues in Labview


Seems we need more generality than is in the current ilemt_ui phase
calibration, to deal with different sensor fixtures, perhaps input sign
flips or even XYZ permutations.

How did we get where we are?  We needed a coupling matrix with the correct
signs.  This requires us to know what phase to expect.  The phase varies
strongly by carrier frequency, due to non-flat frequency response in both
source and input side, and also digital latency on both ends.  But the net
effect is a phase which can be attributed to the source axis (and its
associated carrier frequency).

While we can attribute all of the phase variation to the source axis, the
sensor does actually contribute (via inductance variation), so the phase
calibration is dependent at least on the sensor type.  [If there is
significant mismatch between the sensor coils, then the frequency response
would change also, though perhaps not enough to cause significant sign errors.
To be really thorough, we would need to test the sign of each 3x3 coupling.]

This requires a phase calibration, which has to take place in a pose where we
know the sign of the strong couplings.  Simplest to make this be a particular
"standard" pose, so the signs are fixed.  So far, we assume that:
 1] Phase is measured from couplings on the diagonal (which should be strong),
 2] The couplings have particular signs: +--.

The +-- signs correspond to source and sensor axes aligned, but the sensor
translated out the X axis.  Once the phase has been calibrated it should be
valid in any sensor pose, and should also be quite stable over time, at least
to the accuracy necessary for sign determination.

Where do we want to get to?  The phase calibration should be part of the
complete system calibration (as should the output frequency response).
Currently these exist only in Labview, but the signal processing is going to
move out of labview into C++.  If these calibrations are done in labview, then
the data needs to be exported out of labview.  Currently they come out of
labview through their affect on the saved coupling data.

Because of the phase correction, it doesn't matter if there are sign flips on
the output side.  But sign flips in the input *do* cause problems because it
violates the assumption (in phase correction) that the input channels are
interchangeable.

Suppose we want to be able to work around flipped input signs (which have been
a problem).  The obvious fix is to invert the input signal, and this would
work.  But the inversion only matters insofar as it affects the sign
determination, so this could also be done during phase correction.


[10 May 21]

Summary:
 -- Premo coil data has tangled signs
 -- Coupling bias as measured by shorted input is way less than what we were
    estimating during calibration optimization.
 -- CAT6 cable sheild does not seem to cause metal interference


I took data with the Premo coil, and also got the midsize data with the dipole
coil.

The Premo data seems kind of tangled up wrt signs, fixture orientations, and
the interaction with the Labview phase correction.  At a minimum, the sensor
fixture has a Rz rotation so that X and Y interchange (by observation), and also almost
certainly has Z upside-down (because the package is mounted upside down).
Moving to pose:
    [22, 0, 0, 0, 0, 90]

gives a roughly diagonal coupling matrix with sensible magnitudes, but phase
calibration is probably not forcing the correct signs, since it forces the +--
signs that we get from our previous standard orientation (source and sensor
axes aligned, sensor is placed out along the X axis).

Then there is also the mysterious X input sign flip we were seeing with the
dipole coils, which is unexplained.

I tried getting calibration to figure out sensor fixture and moment
parameters, but it wasn't really working.

Looking at the Premo data in the above pose, relative to the reference levels
for the dipole sensor, all the signs are flipped.  IIRC this is not possible
for a rotation, so some other sign has flipped, perhaps the X has come
unflipped. Say, we rotate 180 degrees about X, then flip the X sign.  And if X
is non-flipped, then we need a positive X source moment again, so not
surprising that calibration was having trouble.

Looked at the actual sensor coil, and the axis directions are as you would
expect based on the label text orientation.  And also, in the fixturing I
chose, the fixture transform is an 180 degree rotation about X.  So that makes
sense together with X getting unflipped.  But reference phase correction is
not going to work without modification.  If we rotate to the +90 Rz then the
strong couplings are on the diagonal, as expected by phase_correct_coupling,
but the signs should then be +++.

Perhaps it would be prettier to rotate the sensor post +90 degrees Rz so that
at least the X for source and sensor are aligned in the stage home position.
But the sensor fixture has to be different from with the dipole sensor because
Z is down.



I collected a bias data point 'bias.dat' with shorted input.  The magnitudes
are much lower than what we were estimating, magnitude for elements is around
2e-6, with norm of the matrix 8e-6.  This is of course just a restatement of
my earlier observation using ilemt_ui that the input shorted reading is around
-100 to -120 dB.  This is small, but is probably a noticeable source of error
at longer ranges where the coupling can be down at 1e-3 or so.


 ==> There is not any detectable effect on the measurement from putting the
     CAT6 cable foil shield near the sensor.
 ==> Calibration not working on the cal_5_7/ dipole sensor data.  Something is
     weird. Oops, I logged the current sense data.  Probably that shouldn't
     happen. 


I think it may not really make sense to publish the dipole/quadrupole results
alone, even once updated, because of new understanding about the big effects
of coil interactions.  We could have published those results, but knowing what
we now know, that is a big omission.  In order to correctly make the argument
that the quadrupole effect measures the accuracy of the dipole approximation,
we need to eliminate any bigger errors.

I've been thinking about a paper on coil interactions and concentic
vs. non-concentric, effects of sensor load and source impedance, etc.  We
could roll this into one paper with dipole effects, or perhaps publish this
first.  


[7 May 21]

I implemented the coupling bias estimation scheme I described.  It
slightly reduces the calibration residual (which it would almost have
to), but somewhat hurts the RMS accuracy.  I'm not sure that it is
reasonable to estimate bias in this way, since the non-bias part of
the residual could have a non-zero mean.  The direct way to get the
bias would be by measuring with the shorted input.


[6 May 21]

Summary:
 -- Thoughts on minimizing possible fixture error.  Fixture error can be
    thought of as inaccurate stage kinematics.
 -- Mutual inductance measured with inductance bridge on the CMU cube source
    and the biggest Premo source are all quite low, < 1e-3.


I got one of the Premo sensors wired up, and getting the fixture post
fabricated.

I need a better understanding of the kinematics of error in the RxRy fixture.

The point of the mechanical alignment procedures is to try to make sure that
the stage kinematics is correct.  So Rz needs to intersect RxRy, etc.  The
sensor fixture pose then allows for the sensor to have an arbitrary pose wrt. the
stage.

But mechanical imprecision in the two mount points creates error.  In addition
to non-squareness causing non-intersection of the axes, translation error also
matters.  One way to model this would be as a sequential link between each of
the rotation axes.  If this includes rotation, then we can even model
non-orthogonality of the mechanical axes.  From the viewpoint of calibration,
this would amount to a more precise kinematics of the stage.

Non-square cross-section of the post or of the mount points also causes non-90
degree rotation, which would not be absorbed into link moments.

First, I would try testing how much of a problem this is, which can be done
mechanically.  All this kinematics seems like a lot of work, and also
absorbing even more DOF into discarded fixture effects seems like it could
absorb real errors.

One possibly test fixture would be a post with a pin sticking out sideways
along what is supposed to be the axis.  I guess you would need to shim the
base of the post to bring in the height to match the actual distance to the
center of rotation.  Can also test parallelism with the translation axes by
reading off the post, and off a square side arm.  OFC this is only an accurate
test insofar is the testing fixture is accurate.  This fixture could be
metal.  Tests for the relative pose of the two mount points can be done with
the sensor mount removed from the stage.

Probably the best way to tune the sensor mount fixture would be to make the
new test fixture, then make the mount agree with it by tweaking in the mount
points.  This potentially solves the height adustment problem, although
tweaking in all the critical faces without going too far is surely tricky.
Perhaps make a new mount rather than tweaking the old one.  I guess finish one
mount, then use the test fixture to bring in the other wrt. to it.

What is the magnitude of the effect of fixture error?  Angular error in the
mount points converts directly to angular error.  Angular error converts to
translation error according to the moment, which is mainly of a concern for
the post height.  This error is basically the non-intersection of the axes.
The moment is the post height, which is only 40mm or so.

What happens with angular errors at the sensor, eg. non-90 degree?  Does this
only affect the angular measurement? Aside from the actual mechanical effect,
there is some rotation->translation coupling in the pose solution itself, but
this effect should be small, so should be very small for a small angular
error.  At least at this point, we mainly want to test and reduce the
rotation->translation coupling seen for large rotations, whether this is
intrinsic in the tracker, or from stage kinematic error.

Looking at the error vectors, there seems to be something like a scale factor
error in Z, where at both + and - Z, the error vectors point inward.  For the
Y effect on error, this mainly seems to be increased magnitude and Rz
coupling, without any clear Y bias at any given point.


I tested the mutual inductance of my cube coil, and also the biggest premo
coil, using the inductance bridge and the shorting method.  Seems to be well
below 1e-3.  I expected higher, 1% or more, especially for my prototype coil.
I think a more sensitive test, especially for the source coil, is to drive in
a current, and then measure the short circuit current on the other axes.  I
could not see any null deflection with my coil, and there was only a just
noticeable deflection with the premo coils.



[4 May 21]

Summary:
 -- Removing input capacitors on ILEMT box greatly improved accuracy.
 -- Worry about stage and fixturing accuracy.  Could be significant.
 -- Fixed the forward kinematics so that the quadrupole actually is a
    quadrupole.  Showing some benefit now, but the fit is not physically
    plausible.  More data needed.
 -- Idea for coupling bias calibration (eg. for within-box out->in cross coupling).



cal_5_3, ILEMT box, with capacitors ripped out.  Cal residue 3-e3.  Was like 4e-4 with Z-only.
________________________________________________________________
                d_source_pos                          d_source_moment                            d_sensor_pos                             d_sensor_moment           
    _____________________________________    __________________________________    ________________________________________    _____________________________________

      0.04597    -0.0010398             0    -0.91124    0.0041408            0      0.013859    -0.00029482              0        -0.18    -0.0029284             0
     0.002147      0.046098             0           0      0.93629            0    0.00018832       0.013518              0            0       0.17954             0
    -0.044444     -0.042867             0    0.030529      0.01112            1     -0.013818      -0.013672              0    0.0028949     0.0010959       0.17915

Source fix: [0.24980 0.02781 -0.03732 0.01354 0.01814 -1.56220 ]
Sensor fix: [0.00004 -0.00003 0.01375 0.00648 -0.00584 1.55604 ]

>> check_poses
data_file = 'Z_rot_ld.dat'
cal_file = 'XYZ_hr_cal.mat'

source_fix_delta =
  -1.0171e-05  -9.4135e-05   4.5581e-05  -0.00062529  -0.00091866     0.001284

sensor_fix_delta =
   9.4835e-05  -8.1182e-06   0.00027099    0.0032535  -7.0148e-05   -0.0035989

Position error (m): 4.14e-04 RMS, 1.43e-03 max.
Orientation error (radians): 3.52e-03 RMS, 1.06e-02 max

trans_err_rms =
   0.00015049   0.00025076   0.00029233

rot_err_rms =
    0.0015903    0.0017429    0.0026125
________________________________________________________________


Woot!  Error is greatly improved, and at 400 um RMS position error, we are
arguably within 2x of our 200 um goal.  (No longer recall whether we said RMS
or max.)  This is with only one fixturing, and will surely be worse with the
three rotations.  We may be nearing the level where ground truth inaccuracy
becomes an issue.

The calibration is somewhat prettier.  The sensor orthogonality is improved
about 2x.  Also, the sensor moment is 0.4x what it was.  This is somewhat
puzzling.  This must have been a gain boost from sensor resonance (which would
have also increased the sensor coil coupling).

Interesting that the source orthogonality is *not* way better compared to the
UR44 setup, even though that did not have off-axis compensation.  But there is
presumably actual non-orthogonality, or at least misalignment which can be
modelled as dipole, so minimizing off-axis terms is only something that is
"pretty". 


This is the "quadrupole" calibration:
________________________________________________________________

               d_source_pos                          d_source_moment                            d_sensor_pos                             d_sensor_moment           
    _____________________________________    __________________________________    ________________________________________    _____________________________________

      0.04597    -0.0010398             0    -0.91124    0.0041408            0      0.013859    -0.00029482              0        -0.18    -0.0029284             0
     0.002147      0.046098             0           0      0.93629            0    0.00018832       0.013518              0            0       0.17954             0
    -0.044444     -0.042867             0    0.030529      0.01112            1     -0.013818      -0.013672              0    0.0028949     0.0010959       0.17915

               q_source_pos                             q_source_moment                 q_sensor_pos    q_sensor_moment
    ___________________________________    _________________________________________    ____________    _______________

     0.097235     0.058666     0.058741      0.0022044    -0.00019983    -0.00050782    0    0    0       0    0    0  
     0.013613     0.065094     0.023188     2.5115e-05     -0.0021705    -6.1818e-05    0    0    0       0    0    0  
    -0.034986    -0.037858     0.006016    -0.00099234     0.00010038     -0.0023726    0    0    0       0    0    0  

Source fix: [0.24894 0.02782 -0.03683 0.01573 0.01695 -1.56067 ]
Sensor fix: [0.00004 -0.00003 0.01374 0.00653 -0.00585 1.55605 ]

>> check_poses
data_file = 'Z_rot_ld.dat'
cal_file = 'quadrupole_hr_cal.mat'

source_fix_delta =
  -1.4243e-05  -6.2832e-05    3.873e-05  -0.00072557  -0.00047574    0.0016535

sensor_fix_delta =
   9.6496e-05  -6.7973e-06   0.00026968    0.0032226  -0.00026451   -0.0037471

Position error (m): 4.28e-04 RMS, 1.42e-03 max.
Orientation error (radians): 3.47e-03 RMS, 9.29e-03 max

trans_err_rms =
   0.00015116   0.00026169   0.00030282

rot_err_rms =
    0.0014608    0.0016343    0.0026881
________________________________________________________________

This is a pretty unexciting improvement, translation RMS is actually slightly
worse, but rotation is improved a bit.  Cal residual reduced from 3.06e-3 down
to 2.84e-3.


Stage performace, from:
    http://filter.micron.ri.cmu.edu/wiki/doku.php?id=projects:asap:calibration:stage
________________________________________________________________

On-axis XYZ repeatability seems to be down around 1 um. Off-axis motion will
of course have both translation and rotation components, but it is difficult
to disentangle because any measurement setup has some moment about whatever
center of rotation there is. On the Z axis, X motion seemed to be within +/-5
um. Angular misalignment of the Z axis has been trimmed down to 100
microradians, at which point runout clearly dominates. Realistically it seems
that for runout + axis misalignment you can expect better than 1 milliradian
(1 micron per mm.) The XY orthogonality seems to be 600 microradians, which is
out of spec, and large enough that it could be affecting Micron
calibration. This would be easier to trim in software.
________________________________________________________________


Stage performance hasn't been directly checked since I wrote this in 2013, so
YMMV.  When compared to the current accuracy (400 um/3.5 mrad RMS), this seems
pretty good.  But need to consider pole moment effects and the RxRy fixture
error (Rz misalignment, etc.).  So far as the pole moment goes, the main issue
would be translation error due to translation->rotation coupling in the XYZ,
and Rz angular runout (Rz to Rx or Ry).

As quick check, If we say the moment is 300mm, then 1 mrad error would create
a 300um offset.  This is significant, so we need to get a better handle on
what we are actually seeing.

FWIW, we are currently getting sensor fixture XY offsets of 40 um.  Does this
reflect on the Rz alignment and RxRy fixture accuracy?  It nominally measures
how well the sensor Z moment is centered on the Rz axis (since the Z dipole
position is forced to 0).  It is not in principle a problem if this were
larger, but the small value is suggestive of actual accuracy.


 ==> I found a bug in the quadrupole forward kinematics which made it into a
     dipole; the two component dipoles did not have opposite signs.

Fixing this did not do much at all until I included dipole in the optimization
also.  With this change, we have so far made somewhat more progress on the
residue, but seem to have pretty much hit the wall at 2.7e-3 after 20
iterations.

Even so, the source X quadrupole moment is changing considerably.  Really need
to let it cook without watching too much, since intermediate states often
don't much resemble the final.
 ==> Conceivably the X quadrupole is bigger because we get closest to that
     coil.

Also, the quadrupole moments are kind of on-axis, but sign flipped.  Being
on-axis is what you would expect if this was absorbing the imperfect dipole
approximation of the ideal dipole-approximating coil geometry.  Or a
rotationally symmetric deviation due to the construction details.  The sensor
parameters (dipole only) don't seem to be changing much, so probably could
speed this up by dropping them out, IDK.  The fixture is not really changing
either, so it seems we are mainly trading the dipole and quadrupole terms
(which is what you would expect).  The dipole positions have moved by mm, and
the source fixture XY by 100's of um.

 ==> The X dipole and quadrupole positions have pretty much converged.

At the very least, I should be using the "medium size" data for calibration.
We may not have enough of the right poses to identify the quadrupole terms.
The way that the quadrupole keeps moving, without any significant effect on
the residual, suggests that we have excess DOF (at least given the data that
we have).  Nothing is "running away" that would give a clear indication, the
dipole components just keep creeping.


 ==> OK, the quadrupole optimization stopped after 88 iterations due to
     FunctionTolerance (failure to reduce the residual), residual 2.741e-3

________________________________________________________________
 
              d_source_pos                         d_source_moment                           d_sensor_pos                             d_sensor_moment           
    _____________________________________    ________________________________    ________________________________________    _____________________________________

      0.05127    -0.0020681             0    -0.89832    0.002791           0      0.013869    -0.00028474              0     -0.18096    -0.0029456             0
    0.0030322      0.044304             0           0     0.93925           0    0.00018272       0.013507              0            0       0.18046             0
    -0.044225      -0.04233             0    0.026178    0.011452           1     -0.013804      -0.013647              0    0.0028849     0.0010959       0.18011

               q_source_pos                           q_source_moment               q_sensor_pos    q_sensor_moment
    ___________________________________    _____________________________________    ____________    _______________

     0.055286     0.032516    -0.035511      0.92092    -0.0014976       0.11243    0    0    0       0    0    0  
    0.0030625    0.0077246      0.06798      0.16303      -0.13046       0.14168    0    0    0       0    0    0  
    -0.044637    -0.046113     0.014332    -0.014069      0.015162      -0.34999    0    0    0       0    0    0  

Source fix: [0.24993 0.02716 -0.03640 0.01553 0.01610 -1.56076 ]
Sensor fix: [0.00004 -0.00004 0.01373 0.00647 -0.00577 1.55603 ]

>> check_poses

data_file = 'Z_rot_ld.dat'
cal_file = 'all_hr_cal.mat'

source_fix_delta= 
  -5.1749e-05  -0.00014413   0.00021821   -0.0007071  -2.3414e-05   0.00044831

sensor_fix_delta =
   8.9371e-05   3.6453e-05   6.5274e-05    0.0031705  -0.00047694   -0.0030639

Position error (m): 3.95e-04 RMS, 1.37e-03 max.
Orientation error (radians): 3.19e-03 RMS, 1.23e-02 max

trans_err_rms =
   0.00013962   0.00023496   0.00028487

rot_err_rms =
    0.0013098    0.0014773    0.0025071
________________________________________________________________


So RMS error is modestly reduced, by 4.5% for position and 9.4% for
orientation.  Worst case error is not really helped, but this may be in part
because the calibration data does not cover the full test workspace (for Rz).
In the position error vectors, the pattern that we are worse at -Y is
maintained.  The Z pattern has become fairly symmetrical + and -, but error is
degraded significantly at the edges of the workspace.

The picture of the calibration is pretty similar to the non-final patterns
noted above.  The sensor parameters indeed hardly changed at all.  I can't
make much sense of how widely the quadrupole moments vary across the source
axes.  I am suspicious that we don't have the right calibration data.  The X
quadrupole seems physically plausible because it is largely on-axis and
located very near the dipole.  Well, all of XYZ moments are tend toward the
axis, and are opposite in sign to the dipole.  But the magnitudes are all over
the place, and the locations also seem somewhat random.


I was thinking that we could compensate the within-box out->in coupling by
calibrating an additive offset to the coupling matrix.  But this would
probably need to be a complex coupling because the internal coupling is likely
to be out of phase.  Also, this won't help the interference on the current
sense, eg. for off-axis compensation.  So it seems worthwhile to try magnetic
shielding around the input cards.
 ==> This is linear in the coupling, basically just the mean of the
     calibration residues.

Specificially, convert the predicted coupling back to complex, difference with
the measurement, and then take the mean.  This could be done separately, or
inside the calibrate objective, as an adjustment to the residues (forcing them
to zero mean).



[28-29 Apr 21]

Summary:
 -- Try working in the +X+Y+Z sector of the corner-dipole source.  This may
    reduce coil interaction effects.  Could explain why -Y and -Z are worse.
 -- The lowest norm of couplings in the large Rz data is 0.07 (-23 dB FS).
    Internal out->in cross-coupling seems better than -100 dB, which seems
    like it ought to be too small to matter.  There are very few measured
    couplings (any 3x3 position) which are <1e-3 re. FS. (-60 dB).  (See
    below)
 -- Turning off the source off-axis compensation *does* make things much
    worse [with corner-dipole source], so it is doing some good.
 -- But even with the compensation on, we are quite definitely worse than with
    the UR44 data...  Suspect increased capacitive load of ILEMT input filters.

re. working in the +X+Y+Z sector only.  I had thought of changing to the
symmetric diagonal source orientation back when we had identified the -Y
problem with Claudia, but then thought that this would create a problem with
our optimization constraint (currently +X).  True that we wouldn't get a
hemisphere anymore, only a 1/8 sphere.  But this is really fairly OK for our
application, and certainly fine as a temporary measure.

For source coil interfaction effects, it makes sense that operating at
negative coordinates would be worse, since in those poses there is an off-axis
coil between the source and the sensor.  Even with the off-axis current
nulled, there can still be interference due to eddy currents (that are not
along the wire, so are not measured).  *source* coil interaction can't explain
the Rz->XYZ coupling (especially in the Rz fixturing, where we rotate about
the coil axis), but sensor coil interaction might.


Coupling magnitude range:

The lowest norm of couplings in the large Rz data is 0.07 (-23 dB FS).  I had
previous measured the box internal cross coupling at -100 to -110 dB, or
1e-5.  This is about -77 dB wrt the min coupling magnitude, which would seem
to be a pretty good margin, except that this is more like the strongest
coupling in the matrix, rather than the weakest coupling that matters.  Given
that, more investigation would be needed to decide whether internal coupling
is a problem.  Our accuracy goal is around -60 dB (200 um @ 200 mm), so we
would want an error significantly less than -83 dB (-60 + -23).  -17 dB would
count as "significantly less", but given the very rough guess of what errors
matter, this is not conclusive.

There are very few measured couplings (any 3x3 position) which are <1e-3
re. FS.


Results with no off-axis compensation:

Not super confident in reproducibility because of that mysterious problem on
my cal_4_21 data, but in cal_4_28_nocomp the calibration residual is much
worse (4.9 vs 0.03?), and the tested accuracy is also worse.

cal_4_28_nocomp (ILEMT box, no off-axis comp), cal residual 4.9
________________________________________________________________

                  d_source_pos                             d_source_moment                           d_sensor_pos                           d_sensor_moment           
    _________________________________________    ___________________________________    ______________________________________    ____________________________________

       0.051667      0.0014064              0     -0.42598     0.040526            0       0.01434     0.0014069             0    -0.44582     -0.015227             0
    -0.00058553       0.046917              0            0      0.59241            0    8.4354e-06      0.014982             0           0       0.45084             0
      -0.044943      -0.044588              0    -0.017994     0.028224            1     -0.013824     -0.014159             0    0.015306    -0.0011999       0.44842

Source fix: [0.25647 0.01748 -0.02935 0.05066 0.00549 -1.60688 ]
Sensor fix: [0.00050 -0.00060 0.01437 0.01086 -0.00895 1.55384 ]

>> check_poses
source_fix_delta =
  -0.00023895  -0.00019102    0.0010144   -0.0019065    -0.005643   -0.0048901

sensor_fix_delta =
  -0.00032916  -0.00026563  -0.00032751    0.0025511    0.0042774   -0.0091584

Position error (m): 3.68e-03 RMS, 1.88e-02 max.
Orientation error (radians): 3.46e-02 RMS, 1.82e-01 max

trans_err_rms =
    0.0008643    0.0030645    0.0018373


rot_err_rms =
     0.013038     0.014659     0.028471
________________________________________________________________


Compare cal_4_23 (ILEMT box, with off-axis comp):
________________________________________________________________

               d_source_pos                           d_source_moment                             d_sensor_pos                            d_sensor_moment           
    _____________________________________    ____________________________________    ________________________________________    ____________________________________

     0.045587    -0.0014909             0     -0.4458    -0.0018872             0      0.013854    -1.0578e-05              0    -0.44857     -0.015882             0
    0.0025708      0.045895             0           0       0.58478             0    0.00022171       0.013749              0           0        0.4567             0
    -0.045172      -0.04339             0    0.011009     0.0042047             1      -0.01365      -0.013878              0    0.015513    -0.0049256       0.45367

Source fix: [0.24952 0.02950 -0.03737 0.01023 0.01238 -1.55465 ]
Sensor fix: [0.00009 -0.00020 0.01400 0.01996 -0.00422 1.54876 ]

>> check_poses
6 invalid points with residual > 0.0001.

bad_points =
     1     2     3     4     5     6

source_fix_delta =
   6.3395e-05  -4.2176e-05   0.00058952    0.0092933   -0.0060007    0.0039225

sensor_fix_delta =
   -3.043e-05  -0.00015105    0.0012648   -0.0062778   -0.0024586   -0.0063608

Position error (m): 2.35e-03 RMS, 1.19e-02 max.
Orientation error (radians): 2.28e-02 RMS, 1.13e-01 max

trans_err_rms =
   0.00057408    0.0018453    0.0013343

rot_err_rms =
    0.0096424     0.010984     0.017527
________________________________________________________________


cal_3_8 (UR44, no off-axis comp), cal residual 0.013
________________________________________________________________

                 d_source_pos                         d_source_moment                           d_sensor_pos                               d_sensor_moment             
    ______________________________________    ________________________________    ________________________________________    _________________________________________

       0.05073      0.002399             0      0.8922    0.062731           0      0.013907    -0.00033894              0       0.066321     -0.0021671              0
    0.00059686      0.047086             0           0     0.94211           0    9.6469e-05       0.013473              0              0        0.10677              0
     -0.043098     -0.042496             0    0.018888    0.042042           1     -0.013736      -0.013652              0    -0.00090121     0.00069743        0.10348

Source fix: [0.23029 0.00690 -0.03037 0.05172 0.01157 -1.59509 ]
Sensor fix: [0.00024 0.00006 0.01365 0.00598 -0.00761 1.55154 ]

>> check_poses

data_file =
    'Z_rot_ld.dat'

cal_file =
    'XYZ_hr_cal.mat'

source_fix_delta =
  -0.00037969   0.00054463  -9.6689e-05   -0.0062639    0.0012081   -0.0047747

sensor_fix_delta =
   0.00040664   0.00044483  -0.00019332    0.0029617    0.0018488     0.011777

Position error (m): 1.04e-03 RMS, 5.70e-03 max.
Orientation error (radians): 1.23e-02 RMS, 5.15e-02 max

trans_err_rms =
   0.00037492   0.00074372   0.00062078

rot_err_rms =
      0.00495    0.0058604    0.0096272

________________________________________________________________


So accuracy is better with off-axis cal than not using ILEMT box, but the old
UR44 setup is much better than either.

UR44:
Position error (m): 1.04e-03 RMS, 5.70e-03 max.
Orientation error (radians): 1.23e-02 RMS, 5.15e-02 max

ILEMT w/ off-axis:
Position error (m): 2.35e-03 RMS, 1.19e-02 max.
Orientation error (radians): 2.28e-02 RMS, 1.13e-01 max

ILEMT w/o off-axis:
Position error (m): 3.68e-03 RMS, 1.88e-02 max.
Orientation error (radians): 3.46e-02 RMS, 1.82e-01 max


I am strongly suspecting that the ILEMT box problem is increased load on the
sensor, especially the C load.  Would be interesting to measure on the UR44.

See ilemt_hw/docs/notebook.txt [29 Apr 21]


[27 Apr 21]

I collected the small three-fixture cal data again, and now that is basically
working also.  I must have goofed somehow with the cal_4_21 data.

But... The pose accuracy is *not* better than what we were getting with the
UR44, perhaps worse.  So far I have only tested with the "small" calibration,
either Rz only, or RzRyRz (dipole only)( And evaluated with various data,
either one of the "small" files, or an Rz big file.

The story is roughly similar with different test data.  With the three-fixture
calibration (vs Rz only), the error seems smoothed out more across the
workspace, not so concentrated along the -Y -Z edge.  Also (at least using the
Rz only big test data) it is clear that coupling from Rz to position is the
big contributor to position error.  That is, there is relatively little
tendency toward a general translation nonlinearity.  That is, the translation
errors at different Rz but the same XYZ are splayed out in all directions
(according to Rz), and not trending in a particular direction (independent of
Rz).

Y and Z error (from Rz cross coupling) are considerably larger than X.  Y
coordinate induced effect creates Y dispersion by Rz, and likewise Z creates Z
dispersion.

I tried quantifying the error pattern as a function of the desired pose, using
covariance, but it is not showing such a strong effect, I think perhaps
because the errors are splaying out somewhat evenly in all directions,
potentially cancelling out, and also the pattern of error magnitude increasing
away from the workspace center is a U-shape relation of error to position, so
is nonlinear.


What could be causing the calibration problem?

[A] Source side problems:
  (1) Coil nonideality, either as-built, or the dipole approximation
  (2) Coil interaction

[B] Sensor side problems:
  (1) Coil interaction
  (2) Coil nonideality, either as-built, or the dipole approximation

[C] Input issues:
  (1) Input load causing sensor coil interaction
  (2) Output -> input coupling inside the box
  (3) Input nonlinearity of measurement

[D] Environment:
  (1) magnetic interference (other than from coils)  The steel box itself?

[E] Ground truth problem:
  (1) error in stage kinematics: our command is wrong, or our expected result
      pose is wrong 
  (2) hardware problem in stage (much less likely)
  (3) motion_server problem

[F] Code problem:
  (1) Error in dipole forward kinematics (doesn't seem too likely)
  (2) Error in pose utilities
  (3) Labview signal processing or logging problem.  Is data stable during
      point data averaging?  Synch problem, increase settling time

[G] Physical/design:
  (1) Does error increase in configurations which are somehow unfavorable for
      the pose solution?  eg. something like singularity or observability.
  (2) Are outlier or difficult measurements throwing off the calibration
      process?
       ==> How are calibration residuals affected by pose?

[H] testing methods:
  (1) Is fixture pose optimization having a non-obvious effect?
       ==> Try using the original calibration fixture pose.


Thoughts:

[A](1), [B](2):
It doesn't make sense that coil nonideality would cause error to increase with
increasing source->sensor distance, since the dipole approximation improves
with distance.  Coil nonideality would almost certainly be larger for the
source, because the coils are larger.
 ==> Does error increase with distance?  How can we characterize the error
     variation? Magnitude of coupling or max coupling?
(The X effect on Rz coupling to Y,Z does seem to increase at lower X, eg. closer)

[C](2): coupling strength (distance) vs. error is also a test for inside-box
coupling, which would be most significant when the actual coupling is quite
small.

[G](1): More generally, look for any pattern in the couplings associated with
error.

[A](2) source cross coupling:
Not too keen on this because this seems to have been greatly reduced, and yet
did not help.
 ==> Take calibration and test data w/o source coupling compensation

(FWIW, the sensor moment non-orthogonality is now about the same as for the
source, a degree or so.  For the sensor, the moments trend away from the
adjacent coils, which is what you would expect for a conductive interferer.)

[B], [C]:
The dominant contribution to error from Rz suggests a sensor referred problem.
But we aren't rotating the source, so who knows what would happen then.
 ==> Take test data with source moved/rotated.  Unlikely to help, except
     perhaps for [D](1), but good to know, and we can do it now using
     check_poses().
 ==> Measure rotational response of coupling. eg. Z sensor coupling should not
     change with Rz.  If it does, then this really looks like a sensor error
     (like coil interaction).  But with off-axis moments, some variation is
     expected.  Can also do this test on X, Y coils in the other fixturings
     (but the sensor seems very symmetric).

[C](2):
Definitely investigate sensor coil interaction, which is one of the
few things I can think of that could explain the ILEMT box being worse (if it
is worse).
 ==> What is the effect of an extra sensor coil moved near the sensor?  Open,
     shorted, C load.
 ==> Any effect on coupling if we disconnect the other sensor axes from the
     input?
 ==> How does C load impedance compare to sensor output impedance?

[D](1):
 ==> Try moving the source, the box, the whole setup across the room, ... 
 ==> Check out low-rate calibration.  Is this better, worse, or the about the
     same? 
 ==> Sniff for interference using the old board test fixture.
 ==> Would be nice to have ilemt_ui feature to visualize small changes in
     field vector orientation.

[E](1): ground truth kinematics error:
 ==> Eyball desired pose
 ==> Some sort of round-trip check on the desired pose kinematics
 ==> We had that problem, with the new Corke toolbox not working, which we never
     investigated.  There could be a problem in our utilities, as well as the
     main code.
 ==> Eyeball/test fk_pose_calculation() and vector2tr()

[E](2) stage hardware:
 ==> Test for any mechanical XY motion as Rz is changed, when off center in XY
     plane.  (Already did this to some degree).
 ==> Don't think motion server actually errors if goal pose is not reached,
     though IIRC if there is a really big error then the labview API will error.

[F](1) dipole forward kinematics:
 ==> Test FK using synthetic data

General investigation:
 ==> Look at error visualizations directly incorporating rotation.  The
     linearity test cross coupling may be useful.  Also scatter plots
 ==> Try changing source/sensor fixture positioning so that we use only the
     +X+Y+Z sector.
 ==> Do we get substantially the same data on repeated identical collection
     runs?  With and without refixturing?
 ==> Matlab code issues should not change between old and new hardware.
 ==> Why does the X input seem inverted?  Might be a software problem.


Specific actions/tests:

High priority tests in lab:
 -- Check sensor coil interaction with extra coil, loaded
 -- Get data without source coupling compensation
 -- Try moving the box, wire, etc, look for effect on ilemt_ui
     ==> Effect of tipping box is nil, small effect when slid back off its
         rear feet, down onto motion rack. 
 -- Set up camera to monitor remote stage operation
 -- Try taking data in only the +X+Y+Z sector.  Rotate source so that the
    diagonal source coil symmetry axis is toward the workspace center.

High priority investigation:
 -- Is accuracy actually worse with new box, compared to Sayan's data?
    Sensor load and box out->in coupling are the most obvious ways that things
    could have gotten worse.  Or if source coupling compensation is actually
    bad.  Current results seem broadly similar to what Claudia got.  The lower
    error Claudia reported is at least partly explained by how we subsetted
    the data, IIRC removing the outer -Y plane.
 -- Look at pose error vs. coupling strength, or more generally, any coupling
    pattern related to error.
 -- Try low rate calibration

Other:
 ==> How are calibration residuals affected by pose?
 ==> Try using the original calibration fixture pose. (in check_poses)
 ==> Measure rotational response of coupling. eg. Z sensor coupling should not
     change with Rz.
[Not exhaustive, see all the ==> above]

Error checks to add:
 -- Propagate ilemt_ui errors (clip) into stage_calibration
 -- Check for excess final position error in motion_server.
 -- Add zero poses at beginning and end of test patterns for drift/bump
    check. 


[24 Apr 21]

Axis offsets:
-2.72	1.552	-3.8	0	0	1.4

Stage alignment check.

Alignment of fixture vertical with stage Z, proxy for normality between
fixture and Rz axis (which we are assuming is parallel to the Z translation
axis).  (Stage Rz @ 90 degrees)

Rx via 25mm Z move, indicated on back of post top mount:
    3 um

Ry via 30mm Z move, indicated on side of fixture post
    125 um


Rz alignment runout, taken at +90 Rz, -90 Rz and 0
	90:  0
	0:   0.031
	-90: 0.060

So basically it is off 30 um in both X and Y.  This is a measure of how
accurately the Rz axis intersects Rx Ry (with some assumption about the
accuracy of the fixtures).  Any non-intersection creates a
rotation->translation moment of the mismatch magnitude.

These alignments all seem fairly reasonable.  The only one that kind of rises
to the level of adjustment is the Ry alignment (pole sideways tip).  But this
has been very soft in the past, difficult to get it to stay below 100 um.
Now, these alignments could certainly contribute 100's of um error across the
workspace, which is a problem for evaluating the desired performance, but
can't explain the 

The Rz runout is going to cause an error of basically that runout. Simple
angular misalignment of the fixture wrt. the stage translation axes is not a
source of error, since the can be absorbed into the fixture transform.  But
non-normality of Rz with Rz Ry is also an error source.  This creates a
magnified error at the edge of the workspace because the points generated by
Rz rotation lie in a different plane that the fixture XY plane.  I guess this
is magnified by the moment ratio of the motion offset vs. the runout
measurment distance.  So over +/-50 mm we would expect about +/- 200 um
above/below the XY plane.

The same magnification would apply to any Rx Ry non-orthogonality (which so
far I have assumed is negligible).


[22 Apr 21]

I got calibration sort of working with data from the ILEMT box.  There seems
to be a sign flip on the sensor X, which is causing both the source and sensor
X moments to be sign flipped.  I recall that this was true with the UR44 also,
and I was negating the X signal in the UR44 settings.

The result calibration is very "pretty", with the off-axis components in the
source moments greatly reduced, and the source fixture also more nearly
aligned in rotation.  The sensor moment magnitudes are almost exactly the same
(because there are no gain knobs).

This is so far only working with the single Z fixturing.  Also, with Sayan's
cal_3_8 data using the UR44, I notice that using Z only gives a much lower
residual.  I am suspicious that I did not do the stage Rz alignment correctly,
since we restarted calibration work with Sayan.  Need to check that the Rz
motion is nulled when moving the stage in "Pose" mode, I had forgotten about
this distinction, and motion_ui defaults to "Absolute axis".


[20 Apr 21]

I did mechanical realignment of the stage.  For the stage vertical and Rz
zero, we were within maybe 500 microns or better on the sweeps of 50-100 mm.
The Rx XY position alignment, which I think is most critical, was off by
around 350 microns.
 ==> Getting the sensor mount zeroed wrt. Rz 0 does not matter at all, because
     we can fold that into the sensor fixture.  Getting the mount vertical is
     modestly important so that the Rz axis is orthogonal to Rx Ry.

What are we depending on for the Rx Ry refixturing to work?  I think it's
basically that the XYZ axes intersect and are orthogonal, where the X and Y
axis location are defined by the center of rotation of the sensor fixture.
Maybe the sensor fixture translation can absorb some of the XY offset of the
Rz axis?  IDK I think there is a problem because of the sequential kinematic
order, but we are simulating Rz being after translation in the kinematic
chain.

My feel is that we are lucky if our accuracy is 100 microns, and 200-300 is
more likely.  The pole is just super easy to bump even 100 microns sideways,
and during a Rz move the pole end tweaks by 10's of microns (though it seems
to settle back).

But at the level of error (mm max) we have gotten so far, I don't think the
ground truth accuracy is limiting.
 ==> With the revived test code with the fixture transform optimization, I can
     try accuracy test with just one fixturing.  This will avoid any
     refixturing error.
